#
# Autogenerated by Thrift Compiler (0.22.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: mojo
#

from collections import Optional

from thrift.protocol.base import TProtocol, TType



@value
struct Type(Representable, Writable, Stringable):
    """
    Types supported by Parquet.  These types are intended to be used in combination
    with the encodings to control the on disk storage format.
    For example INT16 is not included as a type since a good encoding of INT32
    would handle this.

    """
    var value: Int32

    alias BOOLEAN = Type(0)
    alias INT32 = Type(1)
    alias INT64 = Type(2)
    alias INT96 = Type(3)
    alias FLOAT = Type(4)
    alias DOUBLE = Type(5)
    alias BYTE_ARRAY = Type(6)
    alias FIXED_LEN_BYTE_ARRAY = Type(7)

    fn __init__(out self, value: Int32):
        self.value = value

    fn __str__(self) -> String:
        return String.write(self)

    fn __repr__(self) -> String:
        var op: String
        if self.value == 0:
            op = "BOOLEAN"
        elif self.value == 1:
            op = "INT32"
        elif self.value == 2:
            op = "INT64"
        elif self.value == 3:
            op = "INT96"
        elif self.value == 4:
            op = "FLOAT"
        elif self.value == 5:
            op = "DOUBLE"
        elif self.value == 6:
            op = "BYTE_ARRAY"
        elif self.value == 7:
            op = "FIXED_LEN_BYTE_ARRAY"
        else:
            op = "UNKNOWN"
        return String("Type.", op)

    fn __eq__(self, other: Self) -> Bool:
        return self.value == other.value

    fn __ne__(self, other: Self) -> Bool:
        return not (self == other)

    fn to_i32(self) -> Int32:
        return self.value

    fn write_to[W: Writer](self, mut writer: W):
        if self.value == 0:
            writer.write("BOOLEAN")
        elif self.value == 1:
            writer.write("INT32")
        elif self.value == 2:
            writer.write("INT64")
        elif self.value == 3:
            writer.write("INT96")
        elif self.value == 4:
            writer.write("FLOAT")
        elif self.value == 5:
            writer.write("DOUBLE")
        elif self.value == 6:
            writer.write("BYTE_ARRAY")
        elif self.value == 7:
            writer.write("FIXED_LEN_BYTE_ARRAY")
        else:
            writer.write("UNKNOWN")


@value
struct ConvertedType(Representable, Writable, Stringable):
    """
    DEPRECATED: Common types used by frameworks(e.g. hive, pig) using parquet.
    ConvertedType is superseded by LogicalType.  This enum should not be extended.

    See LogicalTypes.md for conversion between ConvertedType and LogicalType.

    """
    var value: Int32

    alias UTF8 = ConvertedType(0)
    alias MAP = ConvertedType(1)
    alias MAP_KEY_VALUE = ConvertedType(2)
    alias LIST = ConvertedType(3)
    alias ENUM = ConvertedType(4)
    alias DECIMAL = ConvertedType(5)
    alias DATE = ConvertedType(6)
    alias TIME_MILLIS = ConvertedType(7)
    alias TIME_MICROS = ConvertedType(8)
    alias TIMESTAMP_MILLIS = ConvertedType(9)
    alias TIMESTAMP_MICROS = ConvertedType(10)
    alias UINT_8 = ConvertedType(11)
    alias UINT_16 = ConvertedType(12)
    alias UINT_32 = ConvertedType(13)
    alias UINT_64 = ConvertedType(14)
    alias INT_8 = ConvertedType(15)
    alias INT_16 = ConvertedType(16)
    alias INT_32 = ConvertedType(17)
    alias INT_64 = ConvertedType(18)
    alias JSON = ConvertedType(19)
    alias BSON = ConvertedType(20)
    alias INTERVAL = ConvertedType(21)

    fn __init__(out self, value: Int32):
        self.value = value

    fn __str__(self) -> String:
        return String.write(self)

    fn __repr__(self) -> String:
        var op: String
        if self.value == 0:
            op = "UTF8"
        elif self.value == 1:
            op = "MAP"
        elif self.value == 2:
            op = "MAP_KEY_VALUE"
        elif self.value == 3:
            op = "LIST"
        elif self.value == 4:
            op = "ENUM"
        elif self.value == 5:
            op = "DECIMAL"
        elif self.value == 6:
            op = "DATE"
        elif self.value == 7:
            op = "TIME_MILLIS"
        elif self.value == 8:
            op = "TIME_MICROS"
        elif self.value == 9:
            op = "TIMESTAMP_MILLIS"
        elif self.value == 10:
            op = "TIMESTAMP_MICROS"
        elif self.value == 11:
            op = "UINT_8"
        elif self.value == 12:
            op = "UINT_16"
        elif self.value == 13:
            op = "UINT_32"
        elif self.value == 14:
            op = "UINT_64"
        elif self.value == 15:
            op = "INT_8"
        elif self.value == 16:
            op = "INT_16"
        elif self.value == 17:
            op = "INT_32"
        elif self.value == 18:
            op = "INT_64"
        elif self.value == 19:
            op = "JSON"
        elif self.value == 20:
            op = "BSON"
        elif self.value == 21:
            op = "INTERVAL"
        else:
            op = "UNKNOWN"
        return String("ConvertedType.", op)

    fn __eq__(self, other: Self) -> Bool:
        return self.value == other.value

    fn __ne__(self, other: Self) -> Bool:
        return not (self == other)

    fn to_i32(self) -> Int32:
        return self.value

    fn write_to[W: Writer](self, mut writer: W):
        if self.value == 0:
            writer.write("UTF8")
        elif self.value == 1:
            writer.write("MAP")
        elif self.value == 2:
            writer.write("MAP_KEY_VALUE")
        elif self.value == 3:
            writer.write("LIST")
        elif self.value == 4:
            writer.write("ENUM")
        elif self.value == 5:
            writer.write("DECIMAL")
        elif self.value == 6:
            writer.write("DATE")
        elif self.value == 7:
            writer.write("TIME_MILLIS")
        elif self.value == 8:
            writer.write("TIME_MICROS")
        elif self.value == 9:
            writer.write("TIMESTAMP_MILLIS")
        elif self.value == 10:
            writer.write("TIMESTAMP_MICROS")
        elif self.value == 11:
            writer.write("UINT_8")
        elif self.value == 12:
            writer.write("UINT_16")
        elif self.value == 13:
            writer.write("UINT_32")
        elif self.value == 14:
            writer.write("UINT_64")
        elif self.value == 15:
            writer.write("INT_8")
        elif self.value == 16:
            writer.write("INT_16")
        elif self.value == 17:
            writer.write("INT_32")
        elif self.value == 18:
            writer.write("INT_64")
        elif self.value == 19:
            writer.write("JSON")
        elif self.value == 20:
            writer.write("BSON")
        elif self.value == 21:
            writer.write("INTERVAL")
        else:
            writer.write("UNKNOWN")


@value
struct FieldRepetitionType(Representable, Writable, Stringable):
    """
    Representation of Schemas

    """
    var value: Int32

    alias REQUIRED = FieldRepetitionType(0)
    alias OPTIONAL = FieldRepetitionType(1)
    alias REPEATED = FieldRepetitionType(2)

    fn __init__(out self, value: Int32):
        self.value = value

    fn __str__(self) -> String:
        return String.write(self)

    fn __repr__(self) -> String:
        var op: String
        if self.value == 0:
            op = "REQUIRED"
        elif self.value == 1:
            op = "OPTIONAL"
        elif self.value == 2:
            op = "REPEATED"
        else:
            op = "UNKNOWN"
        return String("FieldRepetitionType.", op)

    fn __eq__(self, other: Self) -> Bool:
        return self.value == other.value

    fn __ne__(self, other: Self) -> Bool:
        return not (self == other)

    fn to_i32(self) -> Int32:
        return self.value

    fn write_to[W: Writer](self, mut writer: W):
        if self.value == 0:
            writer.write("REQUIRED")
        elif self.value == 1:
            writer.write("OPTIONAL")
        elif self.value == 2:
            writer.write("REPEATED")
        else:
            writer.write("UNKNOWN")


@value
struct EdgeInterpolationAlgorithm(Representable, Writable, Stringable):
    """
    Edge interpolation algorithm for Geography logical type

    """
    var value: Int32

    alias SPHERICAL = EdgeInterpolationAlgorithm(0)
    alias VINCENTY = EdgeInterpolationAlgorithm(1)
    alias THOMAS = EdgeInterpolationAlgorithm(2)
    alias ANDOYER = EdgeInterpolationAlgorithm(3)
    alias KARNEY = EdgeInterpolationAlgorithm(4)

    fn __init__(out self, value: Int32):
        self.value = value

    fn __str__(self) -> String:
        return String.write(self)

    fn __repr__(self) -> String:
        var op: String
        if self.value == 0:
            op = "SPHERICAL"
        elif self.value == 1:
            op = "VINCENTY"
        elif self.value == 2:
            op = "THOMAS"
        elif self.value == 3:
            op = "ANDOYER"
        elif self.value == 4:
            op = "KARNEY"
        else:
            op = "UNKNOWN"
        return String("EdgeInterpolationAlgorithm.", op)

    fn __eq__(self, other: Self) -> Bool:
        return self.value == other.value

    fn __ne__(self, other: Self) -> Bool:
        return not (self == other)

    fn to_i32(self) -> Int32:
        return self.value

    fn write_to[W: Writer](self, mut writer: W):
        if self.value == 0:
            writer.write("SPHERICAL")
        elif self.value == 1:
            writer.write("VINCENTY")
        elif self.value == 2:
            writer.write("THOMAS")
        elif self.value == 3:
            writer.write("ANDOYER")
        elif self.value == 4:
            writer.write("KARNEY")
        else:
            writer.write("UNKNOWN")


@value
struct Encoding(Representable, Writable, Stringable):
    """
    Encodings supported by Parquet.  Not all encodings are valid for all types.  These
    enums are also used to specify the encoding of definition and repetition levels.
    See the accompanying doc for the details of the more complicated encodings.

    """
    var value: Int32

    alias PLAIN = Encoding(0)
    alias PLAIN_DICTIONARY = Encoding(2)
    alias RLE = Encoding(3)
    alias BIT_PACKED = Encoding(4)
    alias DELTA_BINARY_PACKED = Encoding(5)
    alias DELTA_LENGTH_BYTE_ARRAY = Encoding(6)
    alias DELTA_BYTE_ARRAY = Encoding(7)
    alias RLE_DICTIONARY = Encoding(8)
    alias BYTE_STREAM_SPLIT = Encoding(9)

    fn __init__(out self, value: Int32):
        self.value = value

    fn __str__(self) -> String:
        return String.write(self)

    fn __repr__(self) -> String:
        var op: String
        if self.value == 0:
            op = "PLAIN"
        elif self.value == 2:
            op = "PLAIN_DICTIONARY"
        elif self.value == 3:
            op = "RLE"
        elif self.value == 4:
            op = "BIT_PACKED"
        elif self.value == 5:
            op = "DELTA_BINARY_PACKED"
        elif self.value == 6:
            op = "DELTA_LENGTH_BYTE_ARRAY"
        elif self.value == 7:
            op = "DELTA_BYTE_ARRAY"
        elif self.value == 8:
            op = "RLE_DICTIONARY"
        elif self.value == 9:
            op = "BYTE_STREAM_SPLIT"
        else:
            op = "UNKNOWN"
        return String("Encoding.", op)

    fn __eq__(self, other: Self) -> Bool:
        return self.value == other.value

    fn __ne__(self, other: Self) -> Bool:
        return not (self == other)

    fn to_i32(self) -> Int32:
        return self.value

    fn write_to[W: Writer](self, mut writer: W):
        if self.value == 0:
            writer.write("PLAIN")
        elif self.value == 2:
            writer.write("PLAIN_DICTIONARY")
        elif self.value == 3:
            writer.write("RLE")
        elif self.value == 4:
            writer.write("BIT_PACKED")
        elif self.value == 5:
            writer.write("DELTA_BINARY_PACKED")
        elif self.value == 6:
            writer.write("DELTA_LENGTH_BYTE_ARRAY")
        elif self.value == 7:
            writer.write("DELTA_BYTE_ARRAY")
        elif self.value == 8:
            writer.write("RLE_DICTIONARY")
        elif self.value == 9:
            writer.write("BYTE_STREAM_SPLIT")
        else:
            writer.write("UNKNOWN")


@value
struct CompressionCodec(Representable, Writable, Stringable):
    """
    Supported compression algorithms.

    Codecs added in format version X.Y can be read by readers based on X.Y and later.
    Codec support may vary between readers based on the format version and
    libraries available at runtime.

    See Compression.md for a detailed specification of these algorithms.

    """
    var value: Int32

    alias UNCOMPRESSED = CompressionCodec(0)
    alias SNAPPY = CompressionCodec(1)
    alias GZIP = CompressionCodec(2)
    alias LZO = CompressionCodec(3)
    alias BROTLI = CompressionCodec(4)
    alias LZ4 = CompressionCodec(5)
    alias ZSTD = CompressionCodec(6)
    alias LZ4_RAW = CompressionCodec(7)

    fn __init__(out self, value: Int32):
        self.value = value

    fn __str__(self) -> String:
        return String.write(self)

    fn __repr__(self) -> String:
        var op: String
        if self.value == 0:
            op = "UNCOMPRESSED"
        elif self.value == 1:
            op = "SNAPPY"
        elif self.value == 2:
            op = "GZIP"
        elif self.value == 3:
            op = "LZO"
        elif self.value == 4:
            op = "BROTLI"
        elif self.value == 5:
            op = "LZ4"
        elif self.value == 6:
            op = "ZSTD"
        elif self.value == 7:
            op = "LZ4_RAW"
        else:
            op = "UNKNOWN"
        return String("CompressionCodec.", op)

    fn __eq__(self, other: Self) -> Bool:
        return self.value == other.value

    fn __ne__(self, other: Self) -> Bool:
        return not (self == other)

    fn to_i32(self) -> Int32:
        return self.value

    fn write_to[W: Writer](self, mut writer: W):
        if self.value == 0:
            writer.write("UNCOMPRESSED")
        elif self.value == 1:
            writer.write("SNAPPY")
        elif self.value == 2:
            writer.write("GZIP")
        elif self.value == 3:
            writer.write("LZO")
        elif self.value == 4:
            writer.write("BROTLI")
        elif self.value == 5:
            writer.write("LZ4")
        elif self.value == 6:
            writer.write("ZSTD")
        elif self.value == 7:
            writer.write("LZ4_RAW")
        else:
            writer.write("UNKNOWN")


@value
struct PageType(Representable, Writable, Stringable):
    var value: Int32

    alias DATA_PAGE = PageType(0)
    alias INDEX_PAGE = PageType(1)
    alias DICTIONARY_PAGE = PageType(2)
    alias DATA_PAGE_V2 = PageType(3)

    fn __init__(out self, value: Int32):
        self.value = value

    fn __str__(self) -> String:
        return String.write(self)

    fn __repr__(self) -> String:
        var op: String
        if self.value == 0:
            op = "DATA_PAGE"
        elif self.value == 1:
            op = "INDEX_PAGE"
        elif self.value == 2:
            op = "DICTIONARY_PAGE"
        elif self.value == 3:
            op = "DATA_PAGE_V2"
        else:
            op = "UNKNOWN"
        return String("PageType.", op)

    fn __eq__(self, other: Self) -> Bool:
        return self.value == other.value

    fn __ne__(self, other: Self) -> Bool:
        return not (self == other)

    fn to_i32(self) -> Int32:
        return self.value

    fn write_to[W: Writer](self, mut writer: W):
        if self.value == 0:
            writer.write("DATA_PAGE")
        elif self.value == 1:
            writer.write("INDEX_PAGE")
        elif self.value == 2:
            writer.write("DICTIONARY_PAGE")
        elif self.value == 3:
            writer.write("DATA_PAGE_V2")
        else:
            writer.write("UNKNOWN")


@value
struct BoundaryOrder(Representable, Writable, Stringable):
    """
    Enum to annotate whether lists of min/max elements inside ColumnIndex
    are ordered and if so, in which direction.

    """
    var value: Int32

    alias UNORDERED = BoundaryOrder(0)
    alias ASCENDING = BoundaryOrder(1)
    alias DESCENDING = BoundaryOrder(2)

    fn __init__(out self, value: Int32):
        self.value = value

    fn __str__(self) -> String:
        return String.write(self)

    fn __repr__(self) -> String:
        var op: String
        if self.value == 0:
            op = "UNORDERED"
        elif self.value == 1:
            op = "ASCENDING"
        elif self.value == 2:
            op = "DESCENDING"
        else:
            op = "UNKNOWN"
        return String("BoundaryOrder.", op)

    fn __eq__(self, other: Self) -> Bool:
        return self.value == other.value

    fn __ne__(self, other: Self) -> Bool:
        return not (self == other)

    fn to_i32(self) -> Int32:
        return self.value

    fn write_to[W: Writer](self, mut writer: W):
        if self.value == 0:
            writer.write("UNORDERED")
        elif self.value == 1:
            writer.write("ASCENDING")
        elif self.value == 2:
            writer.write("DESCENDING")
        else:
            writer.write("UNKNOWN")


@value 
struct SizeStatistics(Representable):
    """
    A structure for capturing metadata for estimating the unencoded,
    uncompressed size of data written. This is useful for readers to estimate
    how much memory is needed to reconstruct data in their memory model and for
    fine grained filter pushdown on nested structures (the histograms contained
    in this structure can help determine the number of nulls at a particular
    nesting level and maximum length of lists).

    Attributes:
     - unencoded_byte_array_data_bytes: The number of physical bytes stored for BYTE_ARRAY data values assuming
    no encoding. This is exclusive of the bytes needed to store the length of
    each byte array. In other words, this field is equivalent to the `(size
    of PLAIN-ENCODING the byte array values) - (4 bytes * number of values
    written)`. To determine unencoded sizes of other types readers can use
    schema information multiplied by the number of non-null and null values.
    The number of null/non-null values can be inferred from the histograms
    below.

    For example, if a column chunk is dictionary-encoded with dictionary
    ["a", "bc", "cde"], and a data page contains the indices [0, 0, 1, 2],
    then this value for that data page should be 7 (1 + 1 + 2 + 3).

    This field should only be set for types that use BYTE_ARRAY as their
    physical type.
     - repetition_level_histogram: When present, there is expected to be one element corresponding to each
    repetition (i.e. size=max repetition_level+1) where each element
    represents the number of times the repetition level was observed in the
    data.

    This field may be omitted if max_repetition_level is 0 without loss
    of information.

     - definition_level_histogram: Same as repetition_level_histogram except for definition levels.

    This field may be omitted if max_definition_level is 0 or 1 without
    loss of information.


    """
    var unencoded_byte_array_data_bytes: Optional[Int64]
    var repetition_level_histogram: Optional[List[Int64]]
    var definition_level_histogram: Optional[List[Int64]]

    fn __init__(out self, unencoded_byte_array_data_bytes: Optional[Int64], repetition_level_histogram: Optional[List[Int64]], definition_level_histogram: Optional[List[Int64]],):
        self.unencoded_byte_array_data_bytes = unencoded_byte_array_data_bytes
        self.repetition_level_histogram = repetition_level_histogram
        self.definition_level_histogram = definition_level_histogram

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var unencoded_byte_array_data_bytes: Optional[Int64] = None
        var repetition_level_histogram: Optional[List[Int64]] = None
        var definition_level_histogram: Optional[List[Int64]] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.i64:
                    unencoded_byte_array_data_bytes = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.i64)
                    repetition_level_histogram = List[Int64](capacity=size)
                    for _ in range(size):
                        elem_4 = iprot.read_i64()
                        repetition_level_histogram.value().append(elem_4)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.i64)
                    definition_level_histogram = List[Int64](capacity=size)
                    for _ in range(size):
                        elem_9 = iprot.read_i64()
                        definition_level_histogram.value().append(elem_9)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            unencoded_byte_array_data_bytes,
            repetition_level_histogram,
            definition_level_histogram,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.unencoded_byte_array_data_bytes:
            oprot.write_field_begin("unencoded_byte_array_data_bytes", TType.i64, 1)
            oprot.write_i64(self.unencoded_byte_array_data_bytes.value())
            oprot.write_field_end()

        if self.repetition_level_histogram:
            oprot.write_field_begin("repetition_level_histogram", TType.list, 2)
            var size = len(self.repetition_level_histogram.value())
            oprot.write_list_begin(TType.i64, size)
            for iter10 in range(size):
                oprot.write_i64(self.repetition_level_histogram.value()[iter10])
            oprot.write_list_end()
            oprot.write_field_end()

        if self.definition_level_histogram:
            oprot.write_field_begin("definition_level_histogram", TType.list, 3)
            var size = len(self.definition_level_histogram.value())
            oprot.write_list_begin(TType.i64, size)
            for iter11 in range(size):
                oprot.write_i64(self.definition_level_histogram.value()[iter11])
            oprot.write_list_end()
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        if self.unencoded_byte_array_data_bytes:
            unencoded_byte_array_data_bytes = repr(self.unencoded_byte_array_data_bytes.value())
        else:
            unencoded_byte_array_data_bytes = String("None")

        if self.repetition_level_histogram:
            repetition_level_histogram = String("<>")
        else:
            repetition_level_histogram = String("None")

        if self.definition_level_histogram:
            definition_level_histogram = String("<>")
        else:
            definition_level_histogram = String("None")

        return String(
            "SizeStatistics(",
            "Optional(", unencoded_byte_array_data_bytes, "), ",
            "Optional(", repetition_level_histogram, "), ",
            "Optional(", definition_level_histogram, ")",
            ")",
        )



@value 
struct BoundingBox(Representable):
    """
    Bounding box for GEOMETRY or GEOGRAPHY type in the representation of min/max
    value pair of coordinates from each axis.

    Attributes:
     - xmin
     - xmax
     - ymin
     - ymax
     - zmin
     - zmax
     - mmin
     - mmax

    """
    var xmin: Float64
    var xmax: Float64
    var ymin: Float64
    var ymax: Float64
    var zmin: Optional[Float64]
    var zmax: Optional[Float64]
    var mmin: Optional[Float64]
    var mmax: Optional[Float64]

    fn __init__(out self, xmin: Float64, xmax: Float64, ymin: Float64, ymax: Float64, zmin: Optional[Float64], zmax: Optional[Float64], mmin: Optional[Float64], mmax: Optional[Float64],):
        self.xmin = xmin
        self.xmax = xmax
        self.ymin = ymin
        self.ymax = ymax
        self.zmin = zmin
        self.zmax = zmax
        self.mmin = mmin
        self.mmax = mmax

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var xmin: Optional[Float64] = None
        var xmax: Optional[Float64] = None
        var ymin: Optional[Float64] = None
        var ymax: Optional[Float64] = None
        var zmin: Optional[Float64] = None
        var zmax: Optional[Float64] = None
        var mmin: Optional[Float64] = None
        var mmax: Optional[Float64] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.double:
                    xmin = iprot.read_double()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.double:
                    xmax = iprot.read_double()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.double:
                    ymin = iprot.read_double()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.double:
                    ymax = iprot.read_double()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.double:
                    zmin = iprot.read_double()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.double:
                    zmax = iprot.read_double()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.double:
                    mmin = iprot.read_double()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.double:
                    mmax = iprot.read_double()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            xmin.value(),
            xmax.value(),
            ymin.value(),
            ymax.value(),
            zmin,
            zmax,
            mmin,
            mmax,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("xmin", TType.double, 1)
        oprot.write_double(self.xmin)
        oprot.write_field_end()

        oprot.write_field_begin("xmax", TType.double, 2)
        oprot.write_double(self.xmax)
        oprot.write_field_end()

        oprot.write_field_begin("ymin", TType.double, 3)
        oprot.write_double(self.ymin)
        oprot.write_field_end()

        oprot.write_field_begin("ymax", TType.double, 4)
        oprot.write_double(self.ymax)
        oprot.write_field_end()

        if self.zmin:
            oprot.write_field_begin("zmin", TType.double, 5)
            oprot.write_double(self.zmin.value())
            oprot.write_field_end()

        if self.zmax:
            oprot.write_field_begin("zmax", TType.double, 6)
            oprot.write_double(self.zmax.value())
            oprot.write_field_end()

        if self.mmin:
            oprot.write_field_begin("mmin", TType.double, 7)
            oprot.write_double(self.mmin.value())
            oprot.write_field_end()

        if self.mmax:
            oprot.write_field_begin("mmax", TType.double, 8)
            oprot.write_double(self.mmax.value())
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        xmin = repr(self.xmin)

        xmax = repr(self.xmax)

        ymin = repr(self.ymin)

        ymax = repr(self.ymax)

        if self.zmin:
            zmin = repr(self.zmin.value())
        else:
            zmin = String("None")

        if self.zmax:
            zmax = repr(self.zmax.value())
        else:
            zmax = String("None")

        if self.mmin:
            mmin = repr(self.mmin.value())
        else:
            mmin = String("None")

        if self.mmax:
            mmax = repr(self.mmax.value())
        else:
            mmax = String("None")

        return String(
            "BoundingBox(",
            xmin, ", ",
            xmax, ", ",
            ymin, ", ",
            ymax, ", ",
            "Optional(", zmin, "), ",
            "Optional(", zmax, "), ",
            "Optional(", mmin, "), ",
            "Optional(", mmax, ")",
            ")",
        )



@value 
struct GeospatialStatistics(Representable):
    """
    Statistics specific to Geometry and Geography logical types

    Attributes:
     - bbox: A bounding box of geospatial instances
     - geospatial_types: Geospatial type codes of all instances, or an empty list if not known

    """
    var bbox: Optional[BoundingBox]
    var geospatial_types: Optional[List[Int32]]

    fn __init__(out self, bbox: Optional[BoundingBox], geospatial_types: Optional[List[Int32]],):
        self.bbox = bbox
        self.geospatial_types = geospatial_types

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var bbox: Optional[BoundingBox] = None
        var geospatial_types: Optional[List[Int32]] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.struct_:
                    bbox = BoundingBox.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.i32)
                    geospatial_types = List[Int32](capacity=size)
                    for _ in range(size):
                        elem_16 = iprot.read_i32()
                        geospatial_types.value().append(elem_16)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            bbox,
            geospatial_types,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.bbox:
            oprot.write_field_begin("bbox", TType.struct_, 1)
            self.bbox.value().write(oprot)
            oprot.write_field_end()

        if self.geospatial_types:
            oprot.write_field_begin("geospatial_types", TType.list, 2)
            var size = len(self.geospatial_types.value())
            oprot.write_list_begin(TType.i32, size)
            for iter17 in range(size):
                oprot.write_i32(self.geospatial_types.value()[iter17])
            oprot.write_list_end()
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        if self.bbox:
            bbox = repr(self.bbox.value())
        else:
            bbox = String("None")

        if self.geospatial_types:
            geospatial_types = String("<>")
        else:
            geospatial_types = String("None")

        return String(
            "GeospatialStatistics(",
            "Optional(", bbox, "), ",
            "Optional(", geospatial_types, ")",
            ")",
        )



@value 
struct Statistics(Representable):
    """
    Statistics per row group and per page
    All fields are optional.

    Attributes:
     - max: DEPRECATED: min and max value of the column. Use min_value and max_value.

    Values are encoded using PLAIN encoding, except that variable-length byte
    arrays do not include a length prefix.

    These fields encode min and max values determined by signed comparison
    only. New files should use the correct order for a column's logical type
    and store the values in the min_value and max_value fields.

    To support older readers, these may be set when the column order is
    signed.
     - min
     - null_count: Count of null values in the column.

    Writers SHOULD always write this field even if it is zero (i.e. no null value)
    or the column is not nullable.
    Readers MUST distinguish between null_count not being present and null_count == 0.
    If null_count is not present, readers MUST NOT assume null_count == 0.
     - distinct_count: count of distinct values occurring
     - max_value: Lower and upper bound values for the column, determined by its ColumnOrder.

    These may be the actual minimum and maximum values found on a page or column
    chunk, but can also be (more compact) values that do not exist on a page or
    column chunk. For example, instead of storing "Blart Versenwald III", a writer
    may set min_value="B", max_value="C". Such more compact values must still be
    valid values within the column's logical type.

    Values are encoded using PLAIN encoding, except that variable-length byte
    arrays do not include a length prefix.
     - min_value
     - is_max_value_exact: If true, max_value is the actual maximum value for a column
     - is_min_value_exact: If true, min_value is the actual minimum value for a column

    """
    var max: Optional[List[UInt8]]
    var min: Optional[List[UInt8]]
    var null_count: Optional[Int64]
    var distinct_count: Optional[Int64]
    var max_value: Optional[List[UInt8]]
    var min_value: Optional[List[UInt8]]
    var is_max_value_exact: Optional[Bool]
    var is_min_value_exact: Optional[Bool]

    fn __init__(out self, max: Optional[List[UInt8]], min: Optional[List[UInt8]], null_count: Optional[Int64], distinct_count: Optional[Int64], max_value: Optional[List[UInt8]], min_value: Optional[List[UInt8]], is_max_value_exact: Optional[Bool], is_min_value_exact: Optional[Bool],):
        self.max = max
        self.min = min
        self.null_count = null_count
        self.distinct_count = distinct_count
        self.max_value = max_value
        self.min_value = min_value
        self.is_max_value_exact = is_max_value_exact
        self.is_min_value_exact = is_min_value_exact

    @staticmethod
    fn repr_bytes(bytes: List[UInt8]) -> String:
        var s = String("[")
        for i in range(len(bytes)):
            s += repr(bytes[i])
            if i < len(bytes) - 1:
                s += ", "
        s += "]"
        return s

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var max: Optional[List[UInt8]] = None
        var min: Optional[List[UInt8]] = None
        var null_count: Optional[Int64] = None
        var distinct_count: Optional[Int64] = None
        var max_value: Optional[List[UInt8]] = None
        var min_value: Optional[List[UInt8]] = None
        var is_max_value_exact: Optional[Bool] = None
        var is_min_value_exact: Optional[Bool] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.binary:
                    max = iprot.read_binary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.binary:
                    min = iprot.read_binary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.i64:
                    null_count = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.i64:
                    distinct_count = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.binary:
                    max_value = iprot.read_binary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.binary:
                    min_value = iprot.read_binary()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.bool:
                    is_max_value_exact = iprot.read_bool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.bool:
                    is_min_value_exact = iprot.read_bool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            max,
            min,
            null_count,
            distinct_count,
            max_value,
            min_value,
            is_max_value_exact,
            is_min_value_exact,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.max:
            oprot.write_field_begin("max", TType.binary, 1)
            oprot.write_binary(self.max.value())
            oprot.write_field_end()

        if self.min:
            oprot.write_field_begin("min", TType.binary, 2)
            oprot.write_binary(self.min.value())
            oprot.write_field_end()

        if self.null_count:
            oprot.write_field_begin("null_count", TType.i64, 3)
            oprot.write_i64(self.null_count.value())
            oprot.write_field_end()

        if self.distinct_count:
            oprot.write_field_begin("distinct_count", TType.i64, 4)
            oprot.write_i64(self.distinct_count.value())
            oprot.write_field_end()

        if self.max_value:
            oprot.write_field_begin("max_value", TType.binary, 5)
            oprot.write_binary(self.max_value.value())
            oprot.write_field_end()

        if self.min_value:
            oprot.write_field_begin("min_value", TType.binary, 6)
            oprot.write_binary(self.min_value.value())
            oprot.write_field_end()

        if self.is_max_value_exact:
            oprot.write_field_begin("is_max_value_exact", TType.bool, 7)
            oprot.write_bool(self.is_max_value_exact.value())
            oprot.write_field_end()

        if self.is_min_value_exact:
            oprot.write_field_begin("is_min_value_exact", TType.bool, 8)
            oprot.write_bool(self.is_min_value_exact.value())
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        if self.max:
            max = Self.repr_bytes(self.max.value())
        else:
            max = String("None")

        if self.min:
            min = Self.repr_bytes(self.min.value())
        else:
            min = String("None")

        if self.null_count:
            null_count = repr(self.null_count.value())
        else:
            null_count = String("None")

        if self.distinct_count:
            distinct_count = repr(self.distinct_count.value())
        else:
            distinct_count = String("None")

        if self.max_value:
            max_value = Self.repr_bytes(self.max_value.value())
        else:
            max_value = String("None")

        if self.min_value:
            min_value = Self.repr_bytes(self.min_value.value())
        else:
            min_value = String("None")

        if self.is_max_value_exact:
            is_max_value_exact = repr(self.is_max_value_exact.value())
        else:
            is_max_value_exact = String("None")

        if self.is_min_value_exact:
            is_min_value_exact = repr(self.is_min_value_exact.value())
        else:
            is_min_value_exact = String("None")

        return String(
            "Statistics(",
            "Optional(", max, "), ",
            "Optional(", min, "), ",
            "Optional(", null_count, "), ",
            "Optional(", distinct_count, "), ",
            "Optional(", max_value, "), ",
            "Optional(", min_value, "), ",
            "Optional(", is_max_value_exact, "), ",
            "Optional(", is_min_value_exact, ")",
            ")",
        )



@value 
struct StringType(Representable):
    """
    Empty structs to use as logical type annotations

    """

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "StringType(",
            ")",
        )



@value 
struct UUIDType(Representable):

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "UUIDType(",
            ")",
        )



@value 
struct MapType(Representable):

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "MapType(",
            ")",
        )



@value 
struct ListType(Representable):

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "ListType(",
            ")",
        )



@value 
struct EnumType(Representable):

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "EnumType(",
            ")",
        )



@value 
struct DateType(Representable):

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "DateType(",
            ")",
        )



@value 
struct Float16Type(Representable):

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "Float16Type(",
            ")",
        )



@value 
struct NullType(Representable):
    """
    Logical type to annotate a column that is always null.

    Sometimes when discovering the schema of existing data, values are always
    null and the physical type can't be determined. This annotation signals
    the case where the physical type was guessed from all null values.

    """

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "NullType(",
            ")",
        )



@value 
struct DecimalType(Representable):
    """
    Decimal logical type annotation

    Scale must be zero or a positive integer less than or equal to the precision.
    Precision must be a non-zero positive integer.

    To maintain forward-compatibility in v1, implementations using this logical
    type must also set scale and precision on the annotated SchemaElement.

    Allowed for physical types: INT32, INT64, FIXED_LEN_BYTE_ARRAY, and BYTE_ARRAY.

    Attributes:
     - scale
     - precision

    """
    var scale: Int32
    var precision: Int32

    fn __init__(out self, scale: Int32, precision: Int32,):
        self.scale = scale
        self.precision = precision

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var scale: Optional[Int32] = None
        var precision: Optional[Int32] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.i32:
                    scale = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.i32:
                    precision = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            scale.value(),
            precision.value(),
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("scale", TType.i32, 1)
        oprot.write_i32(self.scale)
        oprot.write_field_end()

        oprot.write_field_begin("precision", TType.i32, 2)
        oprot.write_i32(self.precision)
        oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        scale = repr(self.scale)

        precision = repr(self.precision)

        return String(
            "DecimalType(",
            scale, ", ",
            precision,
            ")",
        )



@value 
struct MilliSeconds(Representable):
    """
    Time units for logical types

    """

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "MilliSeconds(",
            ")",
        )



@value 
struct MicroSeconds(Representable):

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "MicroSeconds(",
            ")",
        )



@value 
struct NanoSeconds(Representable):

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "NanoSeconds(",
            ")",
        )



@value 
struct TimeUnit(Representable):
    """
    Attributes:
     - MILLIS
     - MICROS
     - NANOS

    """
    var MILLIS: Optional[MilliSeconds]
    var MICROS: Optional[MicroSeconds]
    var NANOS: Optional[NanoSeconds]

    fn __init__(out self, MILLIS: Optional[MilliSeconds] = None, MICROS: Optional[MicroSeconds] = None, NANOS: Optional[NanoSeconds] = None,):
        self.MILLIS = MILLIS
        self.MICROS = MICROS
        self.NANOS = NANOS

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var MILLIS: Optional[MilliSeconds] = None
        var MICROS: Optional[MicroSeconds] = None
        var NANOS: Optional[NanoSeconds] = None

        var received_field_count = 0

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.struct_:
                    MILLIS = MilliSeconds.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 2:
                if ftype == TType.struct_:
                    MICROS = MicroSeconds.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 3:
                if ftype == TType.struct_:
                    NANOS = NanoSeconds.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        if received_field_count != 1:
            raise Error("Expected exactly one field to be set, but got", received_field_count)

        iprot.read_struct_end()

        return Self(
            MILLIS,
            MICROS,
            NANOS,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.MILLIS:
            oprot.write_field_begin("MILLIS", TType.struct_, 1)
            self.MILLIS.value().write(oprot)
            oprot.write_field_end()

        if self.MICROS:
            oprot.write_field_begin("MICROS", TType.struct_, 2)
            self.MICROS.value().write(oprot)
            oprot.write_field_end()

        if self.NANOS:
            oprot.write_field_begin("NANOS", TType.struct_, 3)
            self.NANOS.value().write(oprot)
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        var inner = String("None")
        if self.MILLIS:
            inner = repr(self.MILLIS.value())

        if self.MICROS:
            inner = repr(self.MICROS.value())

        if self.NANOS:
            inner = repr(self.NANOS.value())

        return String(
            "TimeUnit(",
            inner,
            ")",
        )



@value 
struct TimestampType(Representable):
    """
    Timestamp logical type annotation

    Allowed for physical types: INT64

    Attributes:
     - isAdjustedToUTC
     - unit

    """
    var isAdjustedToUTC: Bool
    var unit: TimeUnit

    fn __init__(out self, isAdjustedToUTC: Bool, unit: TimeUnit,):
        self.isAdjustedToUTC = isAdjustedToUTC
        self.unit = unit

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var isAdjustedToUTC: Optional[Bool] = None
        var unit: Optional[TimeUnit] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.bool:
                    isAdjustedToUTC = iprot.read_bool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.struct_:
                    unit = TimeUnit.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            isAdjustedToUTC.value(),
            unit.value(),
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("isAdjustedToUTC", TType.bool, 1)
        oprot.write_bool(self.isAdjustedToUTC)
        oprot.write_field_end()

        oprot.write_field_begin("unit", TType.struct_, 2)
        self.unit.write(oprot)
        oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        isAdjustedToUTC = repr(self.isAdjustedToUTC)

        unit = repr(self.unit)

        return String(
            "TimestampType(",
            isAdjustedToUTC, ", ",
            unit,
            ")",
        )



@value 
struct TimeType(Representable):
    """
    Time logical type annotation

    Allowed for physical types: INT32 (millis), INT64 (micros, nanos)

    Attributes:
     - isAdjustedToUTC
     - unit

    """
    var isAdjustedToUTC: Bool
    var unit: TimeUnit

    fn __init__(out self, isAdjustedToUTC: Bool, unit: TimeUnit,):
        self.isAdjustedToUTC = isAdjustedToUTC
        self.unit = unit

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var isAdjustedToUTC: Optional[Bool] = None
        var unit: Optional[TimeUnit] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.bool:
                    isAdjustedToUTC = iprot.read_bool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.struct_:
                    unit = TimeUnit.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            isAdjustedToUTC.value(),
            unit.value(),
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("isAdjustedToUTC", TType.bool, 1)
        oprot.write_bool(self.isAdjustedToUTC)
        oprot.write_field_end()

        oprot.write_field_begin("unit", TType.struct_, 2)
        self.unit.write(oprot)
        oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        isAdjustedToUTC = repr(self.isAdjustedToUTC)

        unit = repr(self.unit)

        return String(
            "TimeType(",
            isAdjustedToUTC, ", ",
            unit,
            ")",
        )



@value 
struct IntType(Representable):
    """
    Integer logical type annotation

    bitWidth must be 8, 16, 32, or 64.

    Allowed for physical types: INT32, INT64

    Attributes:
     - bitWidth
     - isSigned

    """
    var bitWidth: Int8
    var isSigned: Bool

    fn __init__(out self, bitWidth: Int8, isSigned: Bool,):
        self.bitWidth = bitWidth
        self.isSigned = isSigned

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var bitWidth: Optional[Int8] = None
        var isSigned: Optional[Bool] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.i8:
                    bitWidth = iprot.read_i8()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.bool:
                    isSigned = iprot.read_bool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            bitWidth.value(),
            isSigned.value(),
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("bitWidth", TType.i8, 1)
        oprot.write_i8(self.bitWidth)
        oprot.write_field_end()

        oprot.write_field_begin("isSigned", TType.bool, 2)
        oprot.write_bool(self.isSigned)
        oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        bitWidth = repr(self.bitWidth)

        isSigned = repr(self.isSigned)

        return String(
            "IntType(",
            bitWidth, ", ",
            isSigned,
            ")",
        )



@value 
struct JsonType(Representable):
    """
    Embedded JSON logical type annotation

    Allowed for physical types: BYTE_ARRAY

    """

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "JsonType(",
            ")",
        )



@value 
struct BsonType(Representable):
    """
    Embedded BSON logical type annotation

    Allowed for physical types: BYTE_ARRAY

    """

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "BsonType(",
            ")",
        )



@value 
struct VariantType(Representable):
    """
    Embedded Variant logical type annotation

    Attributes:
     - specification_version

    """
    var specification_version: Optional[Int8]

    fn __init__(out self, specification_version: Optional[Int8],):
        self.specification_version = specification_version

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var specification_version: Optional[Int8] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.i8:
                    specification_version = iprot.read_i8()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            specification_version,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.specification_version:
            oprot.write_field_begin("specification_version", TType.i8, 1)
            oprot.write_i8(self.specification_version.value())
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        if self.specification_version:
            specification_version = repr(self.specification_version.value())
        else:
            specification_version = String("None")

        return String(
            "VariantType(",
            "Optional(", specification_version, ")",
            ")",
        )



@value 
struct GeometryType(Representable):
    """
    Embedded Geometry logical type annotation

    Geospatial features in the Well-Known Binary (WKB) format and edges interpolation
    is always linear/planar.

    A custom CRS can be set by the crs field. If unset, it defaults to "OGC:CRS84",
    which means that the geometries must be stored in longitude, latitude based on
    the WGS84 datum.

    Allowed for physical type: BYTE_ARRAY.

    See Geospatial.md for details.

    Attributes:
     - crs

    """
    var crs: Optional[String]

    fn __init__(out self, crs: Optional[String],):
        self.crs = crs

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var crs: Optional[String] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.string:
                    crs = iprot.read_string()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            crs,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.crs:
            oprot.write_field_begin("crs", TType.string, 1)
            oprot.write_string(self.crs.value())
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        if self.crs:
            crs = repr(self.crs.value())
        else:
            crs = String("None")

        return String(
            "GeometryType(",
            "Optional(", crs, ")",
            ")",
        )



@value 
struct GeographyType(Representable):
    """
    Embedded Geography logical type annotation

    Geospatial features in the WKB format with an explicit (non-linear/non-planar)
    edges interpolation algorithm.

    A custom geographic CRS can be set by the crs field, where longitudes are
    bound by [-180, 180] and latitudes are bound by [-90, 90]. If unset, the CRS
    defaults to "OGC:CRS84".

    An optional algorithm can be set to correctly interpret edges interpolation
    of the geometries. If unset, the algorithm defaults to SPHERICAL.

    Allowed for physical type: BYTE_ARRAY.

    See Geospatial.md for details.

    Attributes:
     - crs
     - algorithm

    """
    var crs: Optional[String]
    var algorithm: Optional[EdgeInterpolationAlgorithm]

    fn __init__(out self, crs: Optional[String], algorithm: Optional[EdgeInterpolationAlgorithm],):
        self.crs = crs
        self.algorithm = algorithm

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var crs: Optional[String] = None
        var algorithm: Optional[EdgeInterpolationAlgorithm] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.string:
                    crs = iprot.read_string()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.i32:
                    algorithm = EdgeInterpolationAlgorithm(iprot.read_i32())
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            crs,
            algorithm,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.crs:
            oprot.write_field_begin("crs", TType.string, 1)
            oprot.write_string(self.crs.value())
            oprot.write_field_end()

        if self.algorithm:
            oprot.write_field_begin("algorithm", TType.i32, 2)
            oprot.write_i32(self.algorithm.value().to_i32())
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        if self.crs:
            crs = repr(self.crs.value())
        else:
            crs = String("None")

        if self.algorithm:
            algorithm = repr(self.algorithm.value())
        else:
            algorithm = String("None")

        return String(
            "GeographyType(",
            "Optional(", crs, "), ",
            "Optional(", algorithm, ")",
            ")",
        )



@value 
struct LogicalType(Representable):
    """
    LogicalType annotations to replace ConvertedType.

    To maintain compatibility, implementations using LogicalType for a
    SchemaElement must also set the corresponding ConvertedType (if any)
    from the following table.

    Attributes:
     - STRING
     - MAP
     - LIST
     - ENUM
     - DECIMAL
     - DATE
     - TIME
     - TIMESTAMP
     - INTEGER
     - UNKNOWN
     - JSON
     - BSON
     - UUID
     - FLOAT16
     - VARIANT
     - GEOMETRY
     - GEOGRAPHY

    """
    var STRING: Optional[StringType]
    var MAP: Optional[MapType]
    var LIST: Optional[ListType]
    var ENUM: Optional[EnumType]
    var DECIMAL: Optional[DecimalType]
    var DATE: Optional[DateType]
    var TIME: Optional[TimeType]
    var TIMESTAMP: Optional[TimestampType]
    var INTEGER: Optional[IntType]
    var UNKNOWN: Optional[NullType]
    var JSON: Optional[JsonType]
    var BSON: Optional[BsonType]
    var UUID: Optional[UUIDType]
    var FLOAT16: Optional[Float16Type]
    var VARIANT: Optional[VariantType]
    var GEOMETRY: Optional[GeometryType]
    var GEOGRAPHY: Optional[GeographyType]

    fn __init__(out self, STRING: Optional[StringType] = None, MAP: Optional[MapType] = None, LIST: Optional[ListType] = None, ENUM: Optional[EnumType] = None, DECIMAL: Optional[DecimalType] = None, DATE: Optional[DateType] = None, TIME: Optional[TimeType] = None, TIMESTAMP: Optional[TimestampType] = None, INTEGER: Optional[IntType] = None, UNKNOWN: Optional[NullType] = None, JSON: Optional[JsonType] = None, BSON: Optional[BsonType] = None, UUID: Optional[UUIDType] = None, FLOAT16: Optional[Float16Type] = None, VARIANT: Optional[VariantType] = None, GEOMETRY: Optional[GeometryType] = None, GEOGRAPHY: Optional[GeographyType] = None,):
        self.STRING = STRING
        self.MAP = MAP
        self.LIST = LIST
        self.ENUM = ENUM
        self.DECIMAL = DECIMAL
        self.DATE = DATE
        self.TIME = TIME
        self.TIMESTAMP = TIMESTAMP
        self.INTEGER = INTEGER
        self.UNKNOWN = UNKNOWN
        self.JSON = JSON
        self.BSON = BSON
        self.UUID = UUID
        self.FLOAT16 = FLOAT16
        self.VARIANT = VARIANT
        self.GEOMETRY = GEOMETRY
        self.GEOGRAPHY = GEOGRAPHY

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var STRING: Optional[StringType] = None
        var MAP: Optional[MapType] = None
        var LIST: Optional[ListType] = None
        var ENUM: Optional[EnumType] = None
        var DECIMAL: Optional[DecimalType] = None
        var DATE: Optional[DateType] = None
        var TIME: Optional[TimeType] = None
        var TIMESTAMP: Optional[TimestampType] = None
        var INTEGER: Optional[IntType] = None
        var UNKNOWN: Optional[NullType] = None
        var JSON: Optional[JsonType] = None
        var BSON: Optional[BsonType] = None
        var UUID: Optional[UUIDType] = None
        var FLOAT16: Optional[Float16Type] = None
        var VARIANT: Optional[VariantType] = None
        var GEOMETRY: Optional[GeometryType] = None
        var GEOGRAPHY: Optional[GeographyType] = None

        var received_field_count = 0

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.struct_:
                    STRING = StringType.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 2:
                if ftype == TType.struct_:
                    MAP = MapType.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 3:
                if ftype == TType.struct_:
                    LIST = ListType.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 4:
                if ftype == TType.struct_:
                    ENUM = EnumType.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 5:
                if ftype == TType.struct_:
                    DECIMAL = DecimalType.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 6:
                if ftype == TType.struct_:
                    DATE = DateType.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 7:
                if ftype == TType.struct_:
                    TIME = TimeType.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 8:
                if ftype == TType.struct_:
                    TIMESTAMP = TimestampType.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 10:
                if ftype == TType.struct_:
                    INTEGER = IntType.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 11:
                if ftype == TType.struct_:
                    UNKNOWN = NullType.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 12:
                if ftype == TType.struct_:
                    JSON = JsonType.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 13:
                if ftype == TType.struct_:
                    BSON = BsonType.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 14:
                if ftype == TType.struct_:
                    UUID = UUIDType.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 15:
                if ftype == TType.struct_:
                    FLOAT16 = Float16Type.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 16:
                if ftype == TType.struct_:
                    VARIANT = VariantType.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 17:
                if ftype == TType.struct_:
                    GEOMETRY = GeometryType.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 18:
                if ftype == TType.struct_:
                    GEOGRAPHY = GeographyType.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        if received_field_count != 1:
            raise Error("Expected exactly one field to be set, but got", received_field_count)

        iprot.read_struct_end()

        return Self(
            STRING,
            MAP,
            LIST,
            ENUM,
            DECIMAL,
            DATE,
            TIME,
            TIMESTAMP,
            INTEGER,
            UNKNOWN,
            JSON,
            BSON,
            UUID,
            FLOAT16,
            VARIANT,
            GEOMETRY,
            GEOGRAPHY,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.STRING:
            oprot.write_field_begin("STRING", TType.struct_, 1)
            self.STRING.value().write(oprot)
            oprot.write_field_end()

        if self.MAP:
            oprot.write_field_begin("MAP", TType.struct_, 2)
            self.MAP.value().write(oprot)
            oprot.write_field_end()

        if self.LIST:
            oprot.write_field_begin("LIST", TType.struct_, 3)
            self.LIST.value().write(oprot)
            oprot.write_field_end()

        if self.ENUM:
            oprot.write_field_begin("ENUM", TType.struct_, 4)
            self.ENUM.value().write(oprot)
            oprot.write_field_end()

        if self.DECIMAL:
            oprot.write_field_begin("DECIMAL", TType.struct_, 5)
            self.DECIMAL.value().write(oprot)
            oprot.write_field_end()

        if self.DATE:
            oprot.write_field_begin("DATE", TType.struct_, 6)
            self.DATE.value().write(oprot)
            oprot.write_field_end()

        if self.TIME:
            oprot.write_field_begin("TIME", TType.struct_, 7)
            self.TIME.value().write(oprot)
            oprot.write_field_end()

        if self.TIMESTAMP:
            oprot.write_field_begin("TIMESTAMP", TType.struct_, 8)
            self.TIMESTAMP.value().write(oprot)
            oprot.write_field_end()

        if self.INTEGER:
            oprot.write_field_begin("INTEGER", TType.struct_, 10)
            self.INTEGER.value().write(oprot)
            oprot.write_field_end()

        if self.UNKNOWN:
            oprot.write_field_begin("UNKNOWN", TType.struct_, 11)
            self.UNKNOWN.value().write(oprot)
            oprot.write_field_end()

        if self.JSON:
            oprot.write_field_begin("JSON", TType.struct_, 12)
            self.JSON.value().write(oprot)
            oprot.write_field_end()

        if self.BSON:
            oprot.write_field_begin("BSON", TType.struct_, 13)
            self.BSON.value().write(oprot)
            oprot.write_field_end()

        if self.UUID:
            oprot.write_field_begin("UUID", TType.struct_, 14)
            self.UUID.value().write(oprot)
            oprot.write_field_end()

        if self.FLOAT16:
            oprot.write_field_begin("FLOAT16", TType.struct_, 15)
            self.FLOAT16.value().write(oprot)
            oprot.write_field_end()

        if self.VARIANT:
            oprot.write_field_begin("VARIANT", TType.struct_, 16)
            self.VARIANT.value().write(oprot)
            oprot.write_field_end()

        if self.GEOMETRY:
            oprot.write_field_begin("GEOMETRY", TType.struct_, 17)
            self.GEOMETRY.value().write(oprot)
            oprot.write_field_end()

        if self.GEOGRAPHY:
            oprot.write_field_begin("GEOGRAPHY", TType.struct_, 18)
            self.GEOGRAPHY.value().write(oprot)
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        var inner = String("None")
        if self.STRING:
            inner = repr(self.STRING.value())

        if self.MAP:
            inner = repr(self.MAP.value())

        if self.LIST:
            inner = repr(self.LIST.value())

        if self.ENUM:
            inner = repr(self.ENUM.value())

        if self.DECIMAL:
            inner = repr(self.DECIMAL.value())

        if self.DATE:
            inner = repr(self.DATE.value())

        if self.TIME:
            inner = repr(self.TIME.value())

        if self.TIMESTAMP:
            inner = repr(self.TIMESTAMP.value())

        if self.INTEGER:
            inner = repr(self.INTEGER.value())

        if self.UNKNOWN:
            inner = repr(self.UNKNOWN.value())

        if self.JSON:
            inner = repr(self.JSON.value())

        if self.BSON:
            inner = repr(self.BSON.value())

        if self.UUID:
            inner = repr(self.UUID.value())

        if self.FLOAT16:
            inner = repr(self.FLOAT16.value())

        if self.VARIANT:
            inner = repr(self.VARIANT.value())

        if self.GEOMETRY:
            inner = repr(self.GEOMETRY.value())

        if self.GEOGRAPHY:
            inner = repr(self.GEOGRAPHY.value())

        return String(
            "LogicalType(",
            inner,
            ")",
        )



@value 
struct SchemaElement(Representable):
    """
    Represents a element inside a schema definition.
     - if it is a group (inner node) then type is undefined and num_children is defined
     - if it is a primitive type (leaf) then type is defined and num_children is undefined
    the nodes are listed in depth first traversal order.

    Attributes:
     - type: Data type for this field. Not set if the current element is a non-leaf node
     - type_length: If type is FIXED_LEN_BYTE_ARRAY, this is the byte length of the values.
    Otherwise, if specified, this is the maximum bit length to store any of the values.
    (e.g. a low cardinality INT col could have this set to 3).  Note that this is
    in the schema, and therefore fixed for the entire file.
     - repetition_type: repetition of the field. The root of the schema does not have a repetition_type.
    All other nodes must have one
     - name: Name of the field in the schema
     - num_children: Nested fields.  Since thrift does not support nested fields,
    the nesting is flattened to a single list by a depth-first traversal.
    The children count is used to construct the nested relationship.
    This field is not set when the element is a primitive type
     - converted_type: DEPRECATED: When the schema is the result of a conversion from another model.
    Used to record the original type to help with cross conversion.

    This is superseded by logicalType.
     - scale: DEPRECATED: Used when this column contains decimal data.
    See the DECIMAL converted type for more details.

    This is superseded by using the DecimalType annotation in logicalType.
     - precision
     - field_id: When the original schema supports field ids, this will save the
    original field id in the parquet schema
     - logicalType: The logical type of this SchemaElement

    LogicalType replaces ConvertedType, but ConvertedType is still required
    for some logical types to ensure forward-compatibility in format v1.

    """
    var type: Optional[Type]
    var type_length: Optional[Int32]
    var repetition_type: Optional[FieldRepetitionType]
    var name: String
    var num_children: Optional[Int32]
    var converted_type: Optional[ConvertedType]
    var scale: Optional[Int32]
    var precision: Optional[Int32]
    var field_id: Optional[Int32]
    var logicalType: Optional[LogicalType]

    fn __init__(out self, type: Optional[Type], type_length: Optional[Int32], repetition_type: Optional[FieldRepetitionType], name: String, num_children: Optional[Int32], converted_type: Optional[ConvertedType], scale: Optional[Int32], precision: Optional[Int32], field_id: Optional[Int32], logicalType: Optional[LogicalType],):
        self.type = type
        self.type_length = type_length
        self.repetition_type = repetition_type
        self.name = name
        self.num_children = num_children
        self.converted_type = converted_type
        self.scale = scale
        self.precision = precision
        self.field_id = field_id
        self.logicalType = logicalType

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var type: Optional[Type] = None
        var type_length: Optional[Int32] = None
        var repetition_type: Optional[FieldRepetitionType] = None
        var name: Optional[String] = None
        var num_children: Optional[Int32] = None
        var converted_type: Optional[ConvertedType] = None
        var scale: Optional[Int32] = None
        var precision: Optional[Int32] = None
        var field_id: Optional[Int32] = None
        var logicalType: Optional[LogicalType] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.i32:
                    type = Type(iprot.read_i32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.i32:
                    type_length = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.i32:
                    repetition_type = FieldRepetitionType(iprot.read_i32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.string:
                    name = iprot.read_string()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.i32:
                    num_children = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.i32:
                    converted_type = ConvertedType(iprot.read_i32())
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.i32:
                    scale = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.i32:
                    precision = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.i32:
                    field_id = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.struct_:
                    logicalType = LogicalType.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            type,
            type_length,
            repetition_type,
            name.value(),
            num_children,
            converted_type,
            scale,
            precision,
            field_id,
            logicalType,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.type:
            oprot.write_field_begin("type", TType.i32, 1)
            oprot.write_i32(self.type.value().to_i32())
            oprot.write_field_end()

        if self.type_length:
            oprot.write_field_begin("type_length", TType.i32, 2)
            oprot.write_i32(self.type_length.value())
            oprot.write_field_end()

        if self.repetition_type:
            oprot.write_field_begin("repetition_type", TType.i32, 3)
            oprot.write_i32(self.repetition_type.value().to_i32())
            oprot.write_field_end()

        oprot.write_field_begin("name", TType.string, 4)
        oprot.write_string(self.name)
        oprot.write_field_end()

        if self.num_children:
            oprot.write_field_begin("num_children", TType.i32, 5)
            oprot.write_i32(self.num_children.value())
            oprot.write_field_end()

        if self.converted_type:
            oprot.write_field_begin("converted_type", TType.i32, 6)
            oprot.write_i32(self.converted_type.value().to_i32())
            oprot.write_field_end()

        if self.scale:
            oprot.write_field_begin("scale", TType.i32, 7)
            oprot.write_i32(self.scale.value())
            oprot.write_field_end()

        if self.precision:
            oprot.write_field_begin("precision", TType.i32, 8)
            oprot.write_i32(self.precision.value())
            oprot.write_field_end()

        if self.field_id:
            oprot.write_field_begin("field_id", TType.i32, 9)
            oprot.write_i32(self.field_id.value())
            oprot.write_field_end()

        if self.logicalType:
            oprot.write_field_begin("logicalType", TType.struct_, 10)
            self.logicalType.value().write(oprot)
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        if self.type:
            type = repr(self.type.value())
        else:
            type = String("None")

        if self.type_length:
            type_length = repr(self.type_length.value())
        else:
            type_length = String("None")

        if self.repetition_type:
            repetition_type = repr(self.repetition_type.value())
        else:
            repetition_type = String("None")

        name = repr(self.name)

        if self.num_children:
            num_children = repr(self.num_children.value())
        else:
            num_children = String("None")

        if self.converted_type:
            converted_type = repr(self.converted_type.value())
        else:
            converted_type = String("None")

        if self.scale:
            scale = repr(self.scale.value())
        else:
            scale = String("None")

        if self.precision:
            precision = repr(self.precision.value())
        else:
            precision = String("None")

        if self.field_id:
            field_id = repr(self.field_id.value())
        else:
            field_id = String("None")

        if self.logicalType:
            logicalType = repr(self.logicalType.value())
        else:
            logicalType = String("None")

        return String(
            "SchemaElement(",
            "Optional(", type, "), ",
            "Optional(", type_length, "), ",
            "Optional(", repetition_type, "), ",
            name, ", ",
            "Optional(", num_children, "), ",
            "Optional(", converted_type, "), ",
            "Optional(", scale, "), ",
            "Optional(", precision, "), ",
            "Optional(", field_id, "), ",
            "Optional(", logicalType, ")",
            ")",
        )



@value 
struct DataPageHeader(Representable):
    """
    Data page header

    Attributes:
     - num_values: Number of values, including NULLs, in this data page.

    If a OffsetIndex is present, a page must begin at a row
    boundary (repetition_level = 0). Otherwise, pages may begin
    within a row (repetition_level > 0).

     - encoding: Encoding used for this data page *
     - definition_level_encoding: Encoding used for definition levels *
     - repetition_level_encoding: Encoding used for repetition levels *
     - statistics: Optional statistics for the data in this page *

    """
    var num_values: Int32
    var encoding: Encoding
    var definition_level_encoding: Encoding
    var repetition_level_encoding: Encoding
    var statistics: Optional[Statistics]

    fn __init__(out self, num_values: Int32, encoding: Encoding, definition_level_encoding: Encoding, repetition_level_encoding: Encoding, statistics: Optional[Statistics],):
        self.num_values = num_values
        self.encoding = encoding
        self.definition_level_encoding = definition_level_encoding
        self.repetition_level_encoding = repetition_level_encoding
        self.statistics = statistics

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var num_values: Optional[Int32] = None
        var encoding: Optional[Encoding] = None
        var definition_level_encoding: Optional[Encoding] = None
        var repetition_level_encoding: Optional[Encoding] = None
        var statistics: Optional[Statistics] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.i32:
                    num_values = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.i32:
                    encoding = Encoding(iprot.read_i32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.i32:
                    definition_level_encoding = Encoding(iprot.read_i32())
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.i32:
                    repetition_level_encoding = Encoding(iprot.read_i32())
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.struct_:
                    statistics = Statistics.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            num_values.value(),
            encoding.value(),
            definition_level_encoding.value(),
            repetition_level_encoding.value(),
            statistics,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("num_values", TType.i32, 1)
        oprot.write_i32(self.num_values)
        oprot.write_field_end()

        oprot.write_field_begin("encoding", TType.i32, 2)
        oprot.write_i32(self.encoding.to_i32())
        oprot.write_field_end()

        oprot.write_field_begin("definition_level_encoding", TType.i32, 3)
        oprot.write_i32(self.definition_level_encoding.to_i32())
        oprot.write_field_end()

        oprot.write_field_begin("repetition_level_encoding", TType.i32, 4)
        oprot.write_i32(self.repetition_level_encoding.to_i32())
        oprot.write_field_end()

        if self.statistics:
            oprot.write_field_begin("statistics", TType.struct_, 5)
            self.statistics.value().write(oprot)
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        num_values = repr(self.num_values)

        encoding = repr(self.encoding)

        definition_level_encoding = repr(self.definition_level_encoding)

        repetition_level_encoding = repr(self.repetition_level_encoding)

        if self.statistics:
            statistics = repr(self.statistics.value())
        else:
            statistics = String("None")

        return String(
            "DataPageHeader(",
            num_values, ", ",
            encoding, ", ",
            definition_level_encoding, ", ",
            repetition_level_encoding, ", ",
            "Optional(", statistics, ")",
            ")",
        )



@value 
struct IndexPageHeader(Representable):

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "IndexPageHeader(",
            ")",
        )



@value 
struct DictionaryPageHeader(Representable):
    """
    The dictionary page must be placed at the first position of the column chunk
    if it is partly or completely dictionary encoded. At most one dictionary page
    can be placed in a column chunk.


    Attributes:
     - num_values: Number of values in the dictionary *
     - encoding: Encoding using this dictionary page *
     - is_sorted: If true, the entries in the dictionary are sorted in ascending order *

    """
    var num_values: Int32
    var encoding: Encoding
    var is_sorted: Optional[Bool]

    fn __init__(out self, num_values: Int32, encoding: Encoding, is_sorted: Optional[Bool],):
        self.num_values = num_values
        self.encoding = encoding
        self.is_sorted = is_sorted

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var num_values: Optional[Int32] = None
        var encoding: Optional[Encoding] = None
        var is_sorted: Optional[Bool] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.i32:
                    num_values = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.i32:
                    encoding = Encoding(iprot.read_i32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.bool:
                    is_sorted = iprot.read_bool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            num_values.value(),
            encoding.value(),
            is_sorted,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("num_values", TType.i32, 1)
        oprot.write_i32(self.num_values)
        oprot.write_field_end()

        oprot.write_field_begin("encoding", TType.i32, 2)
        oprot.write_i32(self.encoding.to_i32())
        oprot.write_field_end()

        if self.is_sorted:
            oprot.write_field_begin("is_sorted", TType.bool, 3)
            oprot.write_bool(self.is_sorted.value())
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        num_values = repr(self.num_values)

        encoding = repr(self.encoding)

        if self.is_sorted:
            is_sorted = repr(self.is_sorted.value())
        else:
            is_sorted = String("None")

        return String(
            "DictionaryPageHeader(",
            num_values, ", ",
            encoding, ", ",
            "Optional(", is_sorted, ")",
            ")",
        )



@value 
struct DataPageHeaderV2(Representable):
    """
    New page format allowing reading levels without decompressing the data
    Repetition and definition levels are uncompressed
    The remaining section containing the data is compressed if is_compressed is true


    Attributes:
     - num_values: Number of values, including NULLs, in this data page. *
     - num_nulls: Number of NULL values, in this data page.
    Number of non-null = num_values - num_nulls which is also the number of values in the data section *
     - num_rows: Number of rows in this data page. Every page must begin at a
    row boundary (repetition_level = 0): rows must **not** be
    split across page boundaries when using V2 data pages.

     - encoding: Encoding used for data in this page *
     - definition_levels_byte_length: Length of the definition levels
     - repetition_levels_byte_length: Length of the repetition levels
     - is_compressed: Whether the values are compressed.
    Which means the section of the page between
    definition_levels_byte_length + repetition_levels_byte_length + 1 and compressed_page_size (included)
    is compressed with the compression_codec.
    If missing it is considered compressed
     - statistics: Optional statistics for the data in this page *

    """
    var num_values: Int32
    var num_nulls: Int32
    var num_rows: Int32
    var encoding: Encoding
    var definition_levels_byte_length: Int32
    var repetition_levels_byte_length: Int32
    var is_compressed: Optional[Bool]
    var statistics: Optional[Statistics]

    fn __init__(out self, num_values: Int32, num_nulls: Int32, num_rows: Int32, encoding: Encoding, definition_levels_byte_length: Int32, repetition_levels_byte_length: Int32, is_compressed: Optional[Bool], statistics: Optional[Statistics],):
        self.num_values = num_values
        self.num_nulls = num_nulls
        self.num_rows = num_rows
        self.encoding = encoding
        self.definition_levels_byte_length = definition_levels_byte_length
        self.repetition_levels_byte_length = repetition_levels_byte_length
        self.is_compressed = is_compressed
        self.statistics = statistics

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var num_values: Optional[Int32] = None
        var num_nulls: Optional[Int32] = None
        var num_rows: Optional[Int32] = None
        var encoding: Optional[Encoding] = None
        var definition_levels_byte_length: Optional[Int32] = None
        var repetition_levels_byte_length: Optional[Int32] = None
        var is_compressed: Optional[Bool] = True
        var statistics: Optional[Statistics] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.i32:
                    num_values = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.i32:
                    num_nulls = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.i32:
                    num_rows = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.i32:
                    encoding = Encoding(iprot.read_i32())
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.i32:
                    definition_levels_byte_length = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.i32:
                    repetition_levels_byte_length = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.bool:
                    is_compressed = iprot.read_bool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.struct_:
                    statistics = Statistics.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            num_values.value(),
            num_nulls.value(),
            num_rows.value(),
            encoding.value(),
            definition_levels_byte_length.value(),
            repetition_levels_byte_length.value(),
            is_compressed,
            statistics,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("num_values", TType.i32, 1)
        oprot.write_i32(self.num_values)
        oprot.write_field_end()

        oprot.write_field_begin("num_nulls", TType.i32, 2)
        oprot.write_i32(self.num_nulls)
        oprot.write_field_end()

        oprot.write_field_begin("num_rows", TType.i32, 3)
        oprot.write_i32(self.num_rows)
        oprot.write_field_end()

        oprot.write_field_begin("encoding", TType.i32, 4)
        oprot.write_i32(self.encoding.to_i32())
        oprot.write_field_end()

        oprot.write_field_begin("definition_levels_byte_length", TType.i32, 5)
        oprot.write_i32(self.definition_levels_byte_length)
        oprot.write_field_end()

        oprot.write_field_begin("repetition_levels_byte_length", TType.i32, 6)
        oprot.write_i32(self.repetition_levels_byte_length)
        oprot.write_field_end()

        if self.is_compressed:
            oprot.write_field_begin("is_compressed", TType.bool, 7)
            oprot.write_bool(self.is_compressed.value())
            oprot.write_field_end()

        if self.statistics:
            oprot.write_field_begin("statistics", TType.struct_, 8)
            self.statistics.value().write(oprot)
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        num_values = repr(self.num_values)

        num_nulls = repr(self.num_nulls)

        num_rows = repr(self.num_rows)

        encoding = repr(self.encoding)

        definition_levels_byte_length = repr(self.definition_levels_byte_length)

        repetition_levels_byte_length = repr(self.repetition_levels_byte_length)

        if self.is_compressed:
            is_compressed = repr(self.is_compressed.value())
        else:
            is_compressed = String("None")

        if self.statistics:
            statistics = repr(self.statistics.value())
        else:
            statistics = String("None")

        return String(
            "DataPageHeaderV2(",
            num_values, ", ",
            num_nulls, ", ",
            num_rows, ", ",
            encoding, ", ",
            definition_levels_byte_length, ", ",
            repetition_levels_byte_length, ", ",
            "Optional(", is_compressed, "), ",
            "Optional(", statistics, ")",
            ")",
        )



@value 
struct SplitBlockAlgorithm(Representable):
    """
    Block-based algorithm type annotation. *

    """

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "SplitBlockAlgorithm(",
            ")",
        )



@value 
struct BloomFilterAlgorithm(Representable):
    """
    The algorithm used in Bloom filter. *

    Attributes:
     - BLOCK: Block-based Bloom filter. *

    """
    var BLOCK: Optional[SplitBlockAlgorithm]

    fn __init__(out self, BLOCK: Optional[SplitBlockAlgorithm] = None,):
        self.BLOCK = BLOCK

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var BLOCK: Optional[SplitBlockAlgorithm] = None

        var received_field_count = 0

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.struct_:
                    BLOCK = SplitBlockAlgorithm.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        if received_field_count != 1:
            raise Error("Expected exactly one field to be set, but got", received_field_count)

        iprot.read_struct_end()

        return Self(
            BLOCK,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.BLOCK:
            oprot.write_field_begin("BLOCK", TType.struct_, 1)
            self.BLOCK.value().write(oprot)
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        var inner = String("None")
        if self.BLOCK:
            inner = repr(self.BLOCK.value())

        return String(
            "BloomFilterAlgorithm(",
            inner,
            ")",
        )



@value 
struct XxHash(Representable):
    """
    Hash strategy type annotation. xxHash is an extremely fast non-cryptographic hash
    algorithm. It uses 64 bits version of xxHash.


    """

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "XxHash(",
            ")",
        )



@value 
struct BloomFilterHash(Representable):
    """
    The hash function used in Bloom filter. This function takes the hash of a column value
    using plain encoding.


    Attributes:
     - XXHASH: xxHash Strategy. *

    """
    var XXHASH: Optional[XxHash]

    fn __init__(out self, XXHASH: Optional[XxHash] = None,):
        self.XXHASH = XXHASH

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var XXHASH: Optional[XxHash] = None

        var received_field_count = 0

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.struct_:
                    XXHASH = XxHash.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        if received_field_count != 1:
            raise Error("Expected exactly one field to be set, but got", received_field_count)

        iprot.read_struct_end()

        return Self(
            XXHASH,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.XXHASH:
            oprot.write_field_begin("XXHASH", TType.struct_, 1)
            self.XXHASH.value().write(oprot)
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        var inner = String("None")
        if self.XXHASH:
            inner = repr(self.XXHASH.value())

        return String(
            "BloomFilterHash(",
            inner,
            ")",
        )



@value 
struct Uncompressed(Representable):
    """
    The compression used in the Bloom filter.


    """

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "Uncompressed(",
            ")",
        )



@value 
struct BloomFilterCompression(Representable):
    """
    Attributes:
     - UNCOMPRESSED

    """
    var UNCOMPRESSED: Optional[Uncompressed]

    fn __init__(out self, UNCOMPRESSED: Optional[Uncompressed] = None,):
        self.UNCOMPRESSED = UNCOMPRESSED

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var UNCOMPRESSED: Optional[Uncompressed] = None

        var received_field_count = 0

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.struct_:
                    UNCOMPRESSED = Uncompressed.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        if received_field_count != 1:
            raise Error("Expected exactly one field to be set, but got", received_field_count)

        iprot.read_struct_end()

        return Self(
            UNCOMPRESSED,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.UNCOMPRESSED:
            oprot.write_field_begin("UNCOMPRESSED", TType.struct_, 1)
            self.UNCOMPRESSED.value().write(oprot)
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        var inner = String("None")
        if self.UNCOMPRESSED:
            inner = repr(self.UNCOMPRESSED.value())

        return String(
            "BloomFilterCompression(",
            inner,
            ")",
        )



@value 
struct BloomFilterHeader(Representable):
    """
    Bloom filter header is stored at beginning of Bloom filter data of each column
    and followed by its bitset.


    Attributes:
     - numBytes: The size of bitset in bytes *
     - algorithm: The algorithm for setting bits. *
     - hash: The hash function used for Bloom filter. *
     - compression: The compression used in the Bloom filter *

    """
    var numBytes: Int32
    var algorithm: BloomFilterAlgorithm
    var hash: BloomFilterHash
    var compression: BloomFilterCompression

    fn __init__(out self, numBytes: Int32, algorithm: BloomFilterAlgorithm, hash: BloomFilterHash, compression: BloomFilterCompression,):
        self.numBytes = numBytes
        self.algorithm = algorithm
        self.hash = hash
        self.compression = compression

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var numBytes: Optional[Int32] = None
        var algorithm: Optional[BloomFilterAlgorithm] = None
        var hash: Optional[BloomFilterHash] = None
        var compression: Optional[BloomFilterCompression] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.i32:
                    numBytes = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.struct_:
                    algorithm = BloomFilterAlgorithm.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.struct_:
                    hash = BloomFilterHash.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.struct_:
                    compression = BloomFilterCompression.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            numBytes.value(),
            algorithm.value(),
            hash.value(),
            compression.value(),
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("numBytes", TType.i32, 1)
        oprot.write_i32(self.numBytes)
        oprot.write_field_end()

        oprot.write_field_begin("algorithm", TType.struct_, 2)
        self.algorithm.write(oprot)
        oprot.write_field_end()

        oprot.write_field_begin("hash", TType.struct_, 3)
        self.hash.write(oprot)
        oprot.write_field_end()

        oprot.write_field_begin("compression", TType.struct_, 4)
        self.compression.write(oprot)
        oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        numBytes = repr(self.numBytes)

        algorithm = repr(self.algorithm)

        hash = repr(self.hash)

        compression = repr(self.compression)

        return String(
            "BloomFilterHeader(",
            numBytes, ", ",
            algorithm, ", ",
            hash, ", ",
            compression,
            ")",
        )



@value 
struct PageHeader(Representable):
    """
    Attributes:
     - type: the type of the page: indicates which of the *_header fields is set *
     - uncompressed_page_size: Uncompressed page size in bytes (not including this header) *
     - compressed_page_size: Compressed (and potentially encrypted) page size in bytes, not including this header *
     - crc: The 32-bit CRC checksum for the page, to be be calculated as follows:

    - The standard CRC32 algorithm is used (with polynomial 0x04C11DB7,
      the same as in e.g. GZip).
    - All page types can have a CRC (v1 and v2 data pages, dictionary pages,
      etc.).
    - The CRC is computed on the serialization binary representation of the page
      (as written to disk), excluding the page header. For example, for v1
      data pages, the CRC is computed on the concatenation of repetition levels,
      definition levels and column values (optionally compressed, optionally
      encrypted).
    - The CRC computation therefore takes place after any compression
      and encryption steps, if any.

    If enabled, this allows for disabling checksumming in HDFS if only a few
    pages need to be read.
     - data_page_header
     - index_page_header
     - dictionary_page_header
     - data_page_header_v2

    """
    var type: PageType
    var uncompressed_page_size: Int32
    var compressed_page_size: Int32
    var crc: Optional[Int32]
    var data_page_header: Optional[DataPageHeader]
    var index_page_header: Optional[IndexPageHeader]
    var dictionary_page_header: Optional[DictionaryPageHeader]
    var data_page_header_v2: Optional[DataPageHeaderV2]

    fn __init__(out self, type: PageType, uncompressed_page_size: Int32, compressed_page_size: Int32, crc: Optional[Int32], data_page_header: Optional[DataPageHeader], index_page_header: Optional[IndexPageHeader], dictionary_page_header: Optional[DictionaryPageHeader], data_page_header_v2: Optional[DataPageHeaderV2],):
        self.type = type
        self.uncompressed_page_size = uncompressed_page_size
        self.compressed_page_size = compressed_page_size
        self.crc = crc
        self.data_page_header = data_page_header
        self.index_page_header = index_page_header
        self.dictionary_page_header = dictionary_page_header
        self.data_page_header_v2 = data_page_header_v2

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var type: Optional[PageType] = None
        var uncompressed_page_size: Optional[Int32] = None
        var compressed_page_size: Optional[Int32] = None
        var crc: Optional[Int32] = None
        var data_page_header: Optional[DataPageHeader] = None
        var index_page_header: Optional[IndexPageHeader] = None
        var dictionary_page_header: Optional[DictionaryPageHeader] = None
        var data_page_header_v2: Optional[DataPageHeaderV2] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.i32:
                    type = PageType(iprot.read_i32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.i32:
                    uncompressed_page_size = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.i32:
                    compressed_page_size = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.i32:
                    crc = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.struct_:
                    data_page_header = DataPageHeader.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.struct_:
                    index_page_header = IndexPageHeader.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.struct_:
                    dictionary_page_header = DictionaryPageHeader.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.struct_:
                    data_page_header_v2 = DataPageHeaderV2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            type.value(),
            uncompressed_page_size.value(),
            compressed_page_size.value(),
            crc,
            data_page_header,
            index_page_header,
            dictionary_page_header,
            data_page_header_v2,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("type", TType.i32, 1)
        oprot.write_i32(self.type.to_i32())
        oprot.write_field_end()

        oprot.write_field_begin("uncompressed_page_size", TType.i32, 2)
        oprot.write_i32(self.uncompressed_page_size)
        oprot.write_field_end()

        oprot.write_field_begin("compressed_page_size", TType.i32, 3)
        oprot.write_i32(self.compressed_page_size)
        oprot.write_field_end()

        if self.crc:
            oprot.write_field_begin("crc", TType.i32, 4)
            oprot.write_i32(self.crc.value())
            oprot.write_field_end()

        if self.data_page_header:
            oprot.write_field_begin("data_page_header", TType.struct_, 5)
            self.data_page_header.value().write(oprot)
            oprot.write_field_end()

        if self.index_page_header:
            oprot.write_field_begin("index_page_header", TType.struct_, 6)
            self.index_page_header.value().write(oprot)
            oprot.write_field_end()

        if self.dictionary_page_header:
            oprot.write_field_begin("dictionary_page_header", TType.struct_, 7)
            self.dictionary_page_header.value().write(oprot)
            oprot.write_field_end()

        if self.data_page_header_v2:
            oprot.write_field_begin("data_page_header_v2", TType.struct_, 8)
            self.data_page_header_v2.value().write(oprot)
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        type = repr(self.type)

        uncompressed_page_size = repr(self.uncompressed_page_size)

        compressed_page_size = repr(self.compressed_page_size)

        if self.crc:
            crc = repr(self.crc.value())
        else:
            crc = String("None")

        if self.data_page_header:
            data_page_header = repr(self.data_page_header.value())
        else:
            data_page_header = String("None")

        if self.index_page_header:
            index_page_header = repr(self.index_page_header.value())
        else:
            index_page_header = String("None")

        if self.dictionary_page_header:
            dictionary_page_header = repr(self.dictionary_page_header.value())
        else:
            dictionary_page_header = String("None")

        if self.data_page_header_v2:
            data_page_header_v2 = repr(self.data_page_header_v2.value())
        else:
            data_page_header_v2 = String("None")

        return String(
            "PageHeader(",
            type, ", ",
            uncompressed_page_size, ", ",
            compressed_page_size, ", ",
            "Optional(", crc, "), ",
            "Optional(", data_page_header, "), ",
            "Optional(", index_page_header, "), ",
            "Optional(", dictionary_page_header, "), ",
            "Optional(", data_page_header_v2, ")",
            ")",
        )



@value 
struct KeyValue(Representable):
    """
    Wrapper struct to store key values

    Attributes:
     - key
     - value

    """
    var key: String
    var value: Optional[String]

    fn __init__(out self, key: String, value: Optional[String],):
        self.key = key
        self.value = value

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var key: Optional[String] = None
        var value: Optional[String] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.string:
                    key = iprot.read_string()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.string:
                    value = iprot.read_string()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            key.value(),
            value,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("key", TType.string, 1)
        oprot.write_string(self.key)
        oprot.write_field_end()

        if self.value:
            oprot.write_field_begin("value", TType.string, 2)
            oprot.write_string(self.value.value())
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        key = repr(self.key)

        if self.value:
            value = repr(self.value.value())
        else:
            value = String("None")

        return String(
            "KeyValue(",
            key, ", ",
            "Optional(", value, ")",
            ")",
        )



@value 
struct SortingColumn(Representable):
    """
    Sort order within a RowGroup of a leaf column

    Attributes:
     - column_idx: The ordinal position of the column (in this row group) *
     - descending: If true, indicates this column is sorted in descending order. *
     - nulls_first: If true, nulls will come before non-null values, otherwise,
    nulls go at the end.

    """
    var column_idx: Int32
    var descending: Bool
    var nulls_first: Bool

    fn __init__(out self, column_idx: Int32, descending: Bool, nulls_first: Bool,):
        self.column_idx = column_idx
        self.descending = descending
        self.nulls_first = nulls_first

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var column_idx: Optional[Int32] = None
        var descending: Optional[Bool] = None
        var nulls_first: Optional[Bool] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.i32:
                    column_idx = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.bool:
                    descending = iprot.read_bool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.bool:
                    nulls_first = iprot.read_bool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            column_idx.value(),
            descending.value(),
            nulls_first.value(),
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("column_idx", TType.i32, 1)
        oprot.write_i32(self.column_idx)
        oprot.write_field_end()

        oprot.write_field_begin("descending", TType.bool, 2)
        oprot.write_bool(self.descending)
        oprot.write_field_end()

        oprot.write_field_begin("nulls_first", TType.bool, 3)
        oprot.write_bool(self.nulls_first)
        oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        column_idx = repr(self.column_idx)

        descending = repr(self.descending)

        nulls_first = repr(self.nulls_first)

        return String(
            "SortingColumn(",
            column_idx, ", ",
            descending, ", ",
            nulls_first,
            ")",
        )



@value 
struct PageEncodingStats(Representable):
    """
    statistics of a given page type and encoding

    Attributes:
     - page_type: the page type (data/dic/...) *
     - encoding: encoding of the page *
     - count: number of pages of this type with this encoding *

    """
    var page_type: PageType
    var encoding: Encoding
    var count: Int32

    fn __init__(out self, page_type: PageType, encoding: Encoding, count: Int32,):
        self.page_type = page_type
        self.encoding = encoding
        self.count = count

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var page_type: Optional[PageType] = None
        var encoding: Optional[Encoding] = None
        var count: Optional[Int32] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.i32:
                    page_type = PageType(iprot.read_i32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.i32:
                    encoding = Encoding(iprot.read_i32())
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.i32:
                    count = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            page_type.value(),
            encoding.value(),
            count.value(),
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("page_type", TType.i32, 1)
        oprot.write_i32(self.page_type.to_i32())
        oprot.write_field_end()

        oprot.write_field_begin("encoding", TType.i32, 2)
        oprot.write_i32(self.encoding.to_i32())
        oprot.write_field_end()

        oprot.write_field_begin("count", TType.i32, 3)
        oprot.write_i32(self.count)
        oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        page_type = repr(self.page_type)

        encoding = repr(self.encoding)

        count = repr(self.count)

        return String(
            "PageEncodingStats(",
            page_type, ", ",
            encoding, ", ",
            count,
            ")",
        )



@value 
struct ColumnMetaData(Representable):
    """
    Description for column metadata

    Attributes:
     - type: Type of this column *
     - encodings: Set of all encodings used for this column. The purpose is to validate
    whether we can decode those pages. *
     - path_in_schema: Path in schema *
     - codec: Compression codec *
     - num_values: Number of values in this column *
     - total_uncompressed_size: total byte size of all uncompressed pages in this column chunk (including the headers) *
     - total_compressed_size: total byte size of all compressed, and potentially encrypted, pages
    in this column chunk (including the headers) *
     - key_value_metadata: Optional key/value metadata *
     - data_page_offset: Byte offset from beginning of file to first data page *
     - index_page_offset: Byte offset from beginning of file to root index page *
     - dictionary_page_offset: Byte offset from the beginning of file to first (only) dictionary page *
     - statistics: optional statistics for this column chunk
     - encoding_stats: Set of all encodings used for pages in this column chunk.
    This information can be used to determine if all data pages are
    dictionary encoded for example *
     - bloom_filter_offset: Byte offset from beginning of file to Bloom filter data. *
     - bloom_filter_length: Size of Bloom filter data including the serialized header, in bytes.
    Added in 2.10 so readers may not read this field from old files and
    it can be obtained after the BloomFilterHeader has been deserialized.
    Writers should write this field so readers can read the bloom filter
    in a single I/O.
     - size_statistics: Optional statistics to help estimate total memory when converted to in-memory
    representations. The histograms contained in these statistics can
    also be useful in some cases for more fine-grained nullability/list length
    filter pushdown.
     - geospatial_statistics: Optional statistics specific for Geometry and Geography logical types

    """
    var type: Type
    var encodings: List[Encoding]
    var path_in_schema: List[String]
    var codec: CompressionCodec
    var num_values: Int64
    var total_uncompressed_size: Int64
    var total_compressed_size: Int64
    var key_value_metadata: Optional[List[KeyValue]]
    var data_page_offset: Int64
    var index_page_offset: Optional[Int64]
    var dictionary_page_offset: Optional[Int64]
    var statistics: Optional[Statistics]
    var encoding_stats: Optional[List[PageEncodingStats]]
    var bloom_filter_offset: Optional[Int64]
    var bloom_filter_length: Optional[Int32]
    var size_statistics: Optional[SizeStatistics]
    var geospatial_statistics: Optional[GeospatialStatistics]

    fn __init__(out self, type: Type, encodings: List[Encoding], path_in_schema: List[String], codec: CompressionCodec, num_values: Int64, total_uncompressed_size: Int64, total_compressed_size: Int64, key_value_metadata: Optional[List[KeyValue]], data_page_offset: Int64, index_page_offset: Optional[Int64], dictionary_page_offset: Optional[Int64], statistics: Optional[Statistics], encoding_stats: Optional[List[PageEncodingStats]], bloom_filter_offset: Optional[Int64], bloom_filter_length: Optional[Int32], size_statistics: Optional[SizeStatistics], geospatial_statistics: Optional[GeospatialStatistics],):
        self.type = type
        self.encodings = encodings
        self.path_in_schema = path_in_schema
        self.codec = codec
        self.num_values = num_values
        self.total_uncompressed_size = total_uncompressed_size
        self.total_compressed_size = total_compressed_size
        self.key_value_metadata = key_value_metadata
        self.data_page_offset = data_page_offset
        self.index_page_offset = index_page_offset
        self.dictionary_page_offset = dictionary_page_offset
        self.statistics = statistics
        self.encoding_stats = encoding_stats
        self.bloom_filter_offset = bloom_filter_offset
        self.bloom_filter_length = bloom_filter_length
        self.size_statistics = size_statistics
        self.geospatial_statistics = geospatial_statistics

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var type: Optional[Type] = None
        var encodings: Optional[List[Encoding]] = None
        var path_in_schema: Optional[List[String]] = None
        var codec: Optional[CompressionCodec] = None
        var num_values: Optional[Int64] = None
        var total_uncompressed_size: Optional[Int64] = None
        var total_compressed_size: Optional[Int64] = None
        var key_value_metadata: Optional[List[KeyValue]] = None
        var data_page_offset: Optional[Int64] = None
        var index_page_offset: Optional[Int64] = None
        var dictionary_page_offset: Optional[Int64] = None
        var statistics: Optional[Statistics] = None
        var encoding_stats: Optional[List[PageEncodingStats]] = None
        var bloom_filter_offset: Optional[Int64] = None
        var bloom_filter_length: Optional[Int32] = None
        var size_statistics: Optional[SizeStatistics] = None
        var geospatial_statistics: Optional[GeospatialStatistics] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.i32:
                    type = Type(iprot.read_i32())
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.i32)
                    encodings = List[Encoding](capacity=size)
                    for _ in range(size):
                        elem_22 = Encoding(iprot.read_i32())
                        encodings.value().append(elem_22)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.string)
                    path_in_schema = List[String](capacity=size)
                    for _ in range(size):
                        elem_27 = iprot.read_string()
                        path_in_schema.value().append(elem_27)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.i32:
                    codec = CompressionCodec(iprot.read_i32())
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.i64:
                    num_values = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.i64:
                    total_uncompressed_size = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.i64:
                    total_compressed_size = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.struct_)
                    key_value_metadata = List[KeyValue](capacity=size)
                    for _ in range(size):
                        elem_32 = KeyValue.read(iprot)
                        key_value_metadata.value().append(elem_32)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.i64:
                    data_page_offset = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.i64:
                    index_page_offset = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.i64:
                    dictionary_page_offset = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.struct_:
                    statistics = Statistics.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.struct_)
                    encoding_stats = List[PageEncodingStats](capacity=size)
                    for _ in range(size):
                        elem_37 = PageEncodingStats.read(iprot)
                        encoding_stats.value().append(elem_37)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.i64:
                    bloom_filter_offset = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.i32:
                    bloom_filter_length = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.struct_:
                    size_statistics = SizeStatistics.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.struct_:
                    geospatial_statistics = GeospatialStatistics.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            type.value(),
            encodings.value(),
            path_in_schema.value(),
            codec.value(),
            num_values.value(),
            total_uncompressed_size.value(),
            total_compressed_size.value(),
            key_value_metadata,
            data_page_offset.value(),
            index_page_offset,
            dictionary_page_offset,
            statistics,
            encoding_stats,
            bloom_filter_offset,
            bloom_filter_length,
            size_statistics,
            geospatial_statistics,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("type", TType.i32, 1)
        oprot.write_i32(self.type.to_i32())
        oprot.write_field_end()

        oprot.write_field_begin("encodings", TType.list, 2)
        var size = len(self.encodings)
        oprot.write_list_begin(TType.i32, size)
        for iter38 in range(size):
            oprot.write_i32(self.encodings[iter38].to_i32())
        oprot.write_list_end()
        oprot.write_field_end()

        oprot.write_field_begin("path_in_schema", TType.list, 3)
        var size = len(self.path_in_schema)
        oprot.write_list_begin(TType.string, size)
        for iter39 in range(size):
            oprot.write_string(self.path_in_schema[iter39])
        oprot.write_list_end()
        oprot.write_field_end()

        oprot.write_field_begin("codec", TType.i32, 4)
        oprot.write_i32(self.codec.to_i32())
        oprot.write_field_end()

        oprot.write_field_begin("num_values", TType.i64, 5)
        oprot.write_i64(self.num_values)
        oprot.write_field_end()

        oprot.write_field_begin("total_uncompressed_size", TType.i64, 6)
        oprot.write_i64(self.total_uncompressed_size)
        oprot.write_field_end()

        oprot.write_field_begin("total_compressed_size", TType.i64, 7)
        oprot.write_i64(self.total_compressed_size)
        oprot.write_field_end()

        if self.key_value_metadata:
            oprot.write_field_begin("key_value_metadata", TType.list, 8)
            var size = len(self.key_value_metadata.value())
            oprot.write_list_begin(TType.struct_, size)
            for iter40 in range(size):
                self.key_value_metadata.value()[iter40].write(oprot)
            oprot.write_list_end()
            oprot.write_field_end()

        oprot.write_field_begin("data_page_offset", TType.i64, 9)
        oprot.write_i64(self.data_page_offset)
        oprot.write_field_end()

        if self.index_page_offset:
            oprot.write_field_begin("index_page_offset", TType.i64, 10)
            oprot.write_i64(self.index_page_offset.value())
            oprot.write_field_end()

        if self.dictionary_page_offset:
            oprot.write_field_begin("dictionary_page_offset", TType.i64, 11)
            oprot.write_i64(self.dictionary_page_offset.value())
            oprot.write_field_end()

        if self.statistics:
            oprot.write_field_begin("statistics", TType.struct_, 12)
            self.statistics.value().write(oprot)
            oprot.write_field_end()

        if self.encoding_stats:
            oprot.write_field_begin("encoding_stats", TType.list, 13)
            var size = len(self.encoding_stats.value())
            oprot.write_list_begin(TType.struct_, size)
            for iter41 in range(size):
                self.encoding_stats.value()[iter41].write(oprot)
            oprot.write_list_end()
            oprot.write_field_end()

        if self.bloom_filter_offset:
            oprot.write_field_begin("bloom_filter_offset", TType.i64, 14)
            oprot.write_i64(self.bloom_filter_offset.value())
            oprot.write_field_end()

        if self.bloom_filter_length:
            oprot.write_field_begin("bloom_filter_length", TType.i32, 15)
            oprot.write_i32(self.bloom_filter_length.value())
            oprot.write_field_end()

        if self.size_statistics:
            oprot.write_field_begin("size_statistics", TType.struct_, 16)
            self.size_statistics.value().write(oprot)
            oprot.write_field_end()

        if self.geospatial_statistics:
            oprot.write_field_begin("geospatial_statistics", TType.struct_, 17)
            self.geospatial_statistics.value().write(oprot)
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        type = repr(self.type)

        encodings = String("<>")

        path_in_schema = String("<>")

        codec = repr(self.codec)

        num_values = repr(self.num_values)

        total_uncompressed_size = repr(self.total_uncompressed_size)

        total_compressed_size = repr(self.total_compressed_size)

        if self.key_value_metadata:
            key_value_metadata = String("<>")
        else:
            key_value_metadata = String("None")

        data_page_offset = repr(self.data_page_offset)

        if self.index_page_offset:
            index_page_offset = repr(self.index_page_offset.value())
        else:
            index_page_offset = String("None")

        if self.dictionary_page_offset:
            dictionary_page_offset = repr(self.dictionary_page_offset.value())
        else:
            dictionary_page_offset = String("None")

        if self.statistics:
            statistics = repr(self.statistics.value())
        else:
            statistics = String("None")

        if self.encoding_stats:
            encoding_stats = String("<>")
        else:
            encoding_stats = String("None")

        if self.bloom_filter_offset:
            bloom_filter_offset = repr(self.bloom_filter_offset.value())
        else:
            bloom_filter_offset = String("None")

        if self.bloom_filter_length:
            bloom_filter_length = repr(self.bloom_filter_length.value())
        else:
            bloom_filter_length = String("None")

        if self.size_statistics:
            size_statistics = repr(self.size_statistics.value())
        else:
            size_statistics = String("None")

        if self.geospatial_statistics:
            geospatial_statistics = repr(self.geospatial_statistics.value())
        else:
            geospatial_statistics = String("None")

        return String(
            "ColumnMetaData(",
            type, ", ",
            encodings, ", ",
            path_in_schema, ", ",
            codec, ", ",
            num_values, ", ",
            total_uncompressed_size, ", ",
            total_compressed_size, ", ",
            "Optional(", key_value_metadata, "), ",
            data_page_offset, ", ",
            "Optional(", index_page_offset, "), ",
            "Optional(", dictionary_page_offset, "), ",
            "Optional(", statistics, "), ",
            "Optional(", encoding_stats, "), ",
            "Optional(", bloom_filter_offset, "), ",
            "Optional(", bloom_filter_length, "), ",
            "Optional(", size_statistics, "), ",
            "Optional(", geospatial_statistics, ")",
            ")",
        )



@value 
struct EncryptionWithFooterKey(Representable):

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "EncryptionWithFooterKey(",
            ")",
        )



@value 
struct EncryptionWithColumnKey(Representable):
    """
    Attributes:
     - path_in_schema: Column path in schema *
     - key_metadata: Retrieval metadata of column encryption key *

    """
    var path_in_schema: List[String]
    var key_metadata: Optional[List[UInt8]]

    fn __init__(out self, path_in_schema: List[String], key_metadata: Optional[List[UInt8]],):
        self.path_in_schema = path_in_schema
        self.key_metadata = key_metadata

    @staticmethod
    fn repr_bytes(bytes: List[UInt8]) -> String:
        var s = String("[")
        for i in range(len(bytes)):
            s += repr(bytes[i])
            if i < len(bytes) - 1:
                s += ", "
        s += "]"
        return s

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var path_in_schema: Optional[List[String]] = None
        var key_metadata: Optional[List[UInt8]] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.string)
                    path_in_schema = List[String](capacity=size)
                    for _ in range(size):
                        elem_46 = iprot.read_string()
                        path_in_schema.value().append(elem_46)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.binary:
                    key_metadata = iprot.read_binary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            path_in_schema.value(),
            key_metadata,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("path_in_schema", TType.list, 1)
        var size = len(self.path_in_schema)
        oprot.write_list_begin(TType.string, size)
        for iter47 in range(size):
            oprot.write_string(self.path_in_schema[iter47])
        oprot.write_list_end()
        oprot.write_field_end()

        if self.key_metadata:
            oprot.write_field_begin("key_metadata", TType.binary, 2)
            oprot.write_binary(self.key_metadata.value())
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        path_in_schema = String("<>")

        if self.key_metadata:
            key_metadata = Self.repr_bytes(self.key_metadata.value())
        else:
            key_metadata = String("None")

        return String(
            "EncryptionWithColumnKey(",
            path_in_schema, ", ",
            "Optional(", key_metadata, ")",
            ")",
        )



@value 
struct ColumnCryptoMetaData(Representable):
    """
    Attributes:
     - ENCRYPTION_WITH_FOOTER_KEY
     - ENCRYPTION_WITH_COLUMN_KEY

    """
    var ENCRYPTION_WITH_FOOTER_KEY: Optional[EncryptionWithFooterKey]
    var ENCRYPTION_WITH_COLUMN_KEY: Optional[EncryptionWithColumnKey]

    fn __init__(out self, ENCRYPTION_WITH_FOOTER_KEY: Optional[EncryptionWithFooterKey] = None, ENCRYPTION_WITH_COLUMN_KEY: Optional[EncryptionWithColumnKey] = None,):
        self.ENCRYPTION_WITH_FOOTER_KEY = ENCRYPTION_WITH_FOOTER_KEY
        self.ENCRYPTION_WITH_COLUMN_KEY = ENCRYPTION_WITH_COLUMN_KEY

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var ENCRYPTION_WITH_FOOTER_KEY: Optional[EncryptionWithFooterKey] = None
        var ENCRYPTION_WITH_COLUMN_KEY: Optional[EncryptionWithColumnKey] = None

        var received_field_count = 0

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.struct_:
                    ENCRYPTION_WITH_FOOTER_KEY = EncryptionWithFooterKey.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 2:
                if ftype == TType.struct_:
                    ENCRYPTION_WITH_COLUMN_KEY = EncryptionWithColumnKey.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        if received_field_count != 1:
            raise Error("Expected exactly one field to be set, but got", received_field_count)

        iprot.read_struct_end()

        return Self(
            ENCRYPTION_WITH_FOOTER_KEY,
            ENCRYPTION_WITH_COLUMN_KEY,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.ENCRYPTION_WITH_FOOTER_KEY:
            oprot.write_field_begin("ENCRYPTION_WITH_FOOTER_KEY", TType.struct_, 1)
            self.ENCRYPTION_WITH_FOOTER_KEY.value().write(oprot)
            oprot.write_field_end()

        if self.ENCRYPTION_WITH_COLUMN_KEY:
            oprot.write_field_begin("ENCRYPTION_WITH_COLUMN_KEY", TType.struct_, 2)
            self.ENCRYPTION_WITH_COLUMN_KEY.value().write(oprot)
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        var inner = String("None")
        if self.ENCRYPTION_WITH_FOOTER_KEY:
            inner = repr(self.ENCRYPTION_WITH_FOOTER_KEY.value())

        if self.ENCRYPTION_WITH_COLUMN_KEY:
            inner = repr(self.ENCRYPTION_WITH_COLUMN_KEY.value())

        return String(
            "ColumnCryptoMetaData(",
            inner,
            ")",
        )



@value 
struct ColumnChunk(Representable):
    """
    Attributes:
     - file_path: File where column data is stored.  If not set, assumed to be same file as
    metadata.  This path is relative to the current file.

     - file_offset: Deprecated: Byte offset in file_path to the ColumnMetaData

    Past use of this field has been inconsistent, with some implementations
    using it to point to the ColumnMetaData and some using it to point to
    the first page in the column chunk. In many cases, the ColumnMetaData at this
    location is wrong. This field is now deprecated and should not be used.
    Writers should set this field to 0 if no ColumnMetaData has been written outside
    the footer.
     - meta_data: Column metadata for this chunk. Some writers may also replicate this at the
    location pointed to by file_path/file_offset.
    Note: while marked as optional, this field is in fact required by most major
    Parquet implementations. As such, writers MUST populate this field.

     - offset_index_offset: File offset of ColumnChunk's OffsetIndex *
     - offset_index_length: Size of ColumnChunk's OffsetIndex, in bytes *
     - column_index_offset: File offset of ColumnChunk's ColumnIndex *
     - column_index_length: Size of ColumnChunk's ColumnIndex, in bytes *
     - crypto_metadata: Crypto metadata of encrypted columns *
     - encrypted_column_metadata: Encrypted column metadata for this chunk *

    """
    var file_path: Optional[String]
    var file_offset: Int64
    var meta_data: Optional[ColumnMetaData]
    var offset_index_offset: Optional[Int64]
    var offset_index_length: Optional[Int32]
    var column_index_offset: Optional[Int64]
    var column_index_length: Optional[Int32]
    var crypto_metadata: Optional[ColumnCryptoMetaData]
    var encrypted_column_metadata: Optional[List[UInt8]]

    fn __init__(out self, file_path: Optional[String], file_offset: Int64, meta_data: Optional[ColumnMetaData], offset_index_offset: Optional[Int64], offset_index_length: Optional[Int32], column_index_offset: Optional[Int64], column_index_length: Optional[Int32], crypto_metadata: Optional[ColumnCryptoMetaData], encrypted_column_metadata: Optional[List[UInt8]],):
        self.file_path = file_path
        self.file_offset = file_offset
        self.meta_data = meta_data
        self.offset_index_offset = offset_index_offset
        self.offset_index_length = offset_index_length
        self.column_index_offset = column_index_offset
        self.column_index_length = column_index_length
        self.crypto_metadata = crypto_metadata
        self.encrypted_column_metadata = encrypted_column_metadata

    @staticmethod
    fn repr_bytes(bytes: List[UInt8]) -> String:
        var s = String("[")
        for i in range(len(bytes)):
            s += repr(bytes[i])
            if i < len(bytes) - 1:
                s += ", "
        s += "]"
        return s

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var file_path: Optional[String] = None
        var file_offset: Optional[Int64] = Int64(0)
        var meta_data: Optional[ColumnMetaData] = None
        var offset_index_offset: Optional[Int64] = None
        var offset_index_length: Optional[Int32] = None
        var column_index_offset: Optional[Int64] = None
        var column_index_length: Optional[Int32] = None
        var crypto_metadata: Optional[ColumnCryptoMetaData] = None
        var encrypted_column_metadata: Optional[List[UInt8]] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.string:
                    file_path = iprot.read_string()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.i64:
                    file_offset = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.struct_:
                    meta_data = ColumnMetaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.i64:
                    offset_index_offset = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.i32:
                    offset_index_length = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.i64:
                    column_index_offset = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.i32:
                    column_index_length = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.struct_:
                    crypto_metadata = ColumnCryptoMetaData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.binary:
                    encrypted_column_metadata = iprot.read_binary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            file_path,
            file_offset.value(),
            meta_data,
            offset_index_offset,
            offset_index_length,
            column_index_offset,
            column_index_length,
            crypto_metadata,
            encrypted_column_metadata,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.file_path:
            oprot.write_field_begin("file_path", TType.string, 1)
            oprot.write_string(self.file_path.value())
            oprot.write_field_end()

        oprot.write_field_begin("file_offset", TType.i64, 2)
        oprot.write_i64(self.file_offset)
        oprot.write_field_end()

        if self.meta_data:
            oprot.write_field_begin("meta_data", TType.struct_, 3)
            self.meta_data.value().write(oprot)
            oprot.write_field_end()

        if self.offset_index_offset:
            oprot.write_field_begin("offset_index_offset", TType.i64, 4)
            oprot.write_i64(self.offset_index_offset.value())
            oprot.write_field_end()

        if self.offset_index_length:
            oprot.write_field_begin("offset_index_length", TType.i32, 5)
            oprot.write_i32(self.offset_index_length.value())
            oprot.write_field_end()

        if self.column_index_offset:
            oprot.write_field_begin("column_index_offset", TType.i64, 6)
            oprot.write_i64(self.column_index_offset.value())
            oprot.write_field_end()

        if self.column_index_length:
            oprot.write_field_begin("column_index_length", TType.i32, 7)
            oprot.write_i32(self.column_index_length.value())
            oprot.write_field_end()

        if self.crypto_metadata:
            oprot.write_field_begin("crypto_metadata", TType.struct_, 8)
            self.crypto_metadata.value().write(oprot)
            oprot.write_field_end()

        if self.encrypted_column_metadata:
            oprot.write_field_begin("encrypted_column_metadata", TType.binary, 9)
            oprot.write_binary(self.encrypted_column_metadata.value())
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        if self.file_path:
            file_path = repr(self.file_path.value())
        else:
            file_path = String("None")

        file_offset = repr(self.file_offset)

        if self.meta_data:
            meta_data = repr(self.meta_data.value())
        else:
            meta_data = String("None")

        if self.offset_index_offset:
            offset_index_offset = repr(self.offset_index_offset.value())
        else:
            offset_index_offset = String("None")

        if self.offset_index_length:
            offset_index_length = repr(self.offset_index_length.value())
        else:
            offset_index_length = String("None")

        if self.column_index_offset:
            column_index_offset = repr(self.column_index_offset.value())
        else:
            column_index_offset = String("None")

        if self.column_index_length:
            column_index_length = repr(self.column_index_length.value())
        else:
            column_index_length = String("None")

        if self.crypto_metadata:
            crypto_metadata = repr(self.crypto_metadata.value())
        else:
            crypto_metadata = String("None")

        if self.encrypted_column_metadata:
            encrypted_column_metadata = Self.repr_bytes(self.encrypted_column_metadata.value())
        else:
            encrypted_column_metadata = String("None")

        return String(
            "ColumnChunk(",
            "Optional(", file_path, "), ",
            file_offset, ", ",
            "Optional(", meta_data, "), ",
            "Optional(", offset_index_offset, "), ",
            "Optional(", offset_index_length, "), ",
            "Optional(", column_index_offset, "), ",
            "Optional(", column_index_length, "), ",
            "Optional(", crypto_metadata, "), ",
            "Optional(", encrypted_column_metadata, ")",
            ")",
        )



@value 
struct RowGroup(Representable):
    """
    Attributes:
     - columns: Metadata for each column chunk in this row group.
    This list must have the same order as the SchemaElement list in FileMetaData.

     - total_byte_size: Total byte size of all the uncompressed column data in this row group *
     - num_rows: Number of rows in this row group *
     - sorting_columns: If set, specifies a sort ordering of the rows in this RowGroup.
    The sorting columns can be a subset of all the columns.
     - file_offset: Byte offset from beginning of file to first page (data or dictionary)
    in this row group *
     - total_compressed_size: Total byte size of all compressed (and potentially encrypted) column data
    in this row group *
     - ordinal: Row group ordinal in the file *

    """
    var columns: List[ColumnChunk]
    var total_byte_size: Int64
    var num_rows: Int64
    var sorting_columns: Optional[List[SortingColumn]]
    var file_offset: Optional[Int64]
    var total_compressed_size: Optional[Int64]
    var ordinal: Optional[Int16]

    fn __init__(out self, columns: List[ColumnChunk], total_byte_size: Int64, num_rows: Int64, sorting_columns: Optional[List[SortingColumn]], file_offset: Optional[Int64], total_compressed_size: Optional[Int64], ordinal: Optional[Int16],):
        self.columns = columns
        self.total_byte_size = total_byte_size
        self.num_rows = num_rows
        self.sorting_columns = sorting_columns
        self.file_offset = file_offset
        self.total_compressed_size = total_compressed_size
        self.ordinal = ordinal

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var columns: Optional[List[ColumnChunk]] = None
        var total_byte_size: Optional[Int64] = None
        var num_rows: Optional[Int64] = None
        var sorting_columns: Optional[List[SortingColumn]] = None
        var file_offset: Optional[Int64] = None
        var total_compressed_size: Optional[Int64] = None
        var ordinal: Optional[Int16] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.struct_)
                    columns = List[ColumnChunk](capacity=size)
                    for _ in range(size):
                        elem_52 = ColumnChunk.read(iprot)
                        columns.value().append(elem_52)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.i64:
                    total_byte_size = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.i64:
                    num_rows = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.struct_)
                    sorting_columns = List[SortingColumn](capacity=size)
                    for _ in range(size):
                        elem_57 = SortingColumn.read(iprot)
                        sorting_columns.value().append(elem_57)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.i64:
                    file_offset = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.i64:
                    total_compressed_size = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.i16:
                    ordinal = iprot.read_i16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            columns.value(),
            total_byte_size.value(),
            num_rows.value(),
            sorting_columns,
            file_offset,
            total_compressed_size,
            ordinal,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("columns", TType.list, 1)
        var size = len(self.columns)
        oprot.write_list_begin(TType.struct_, size)
        for iter58 in range(size):
            self.columns[iter58].write(oprot)
        oprot.write_list_end()
        oprot.write_field_end()

        oprot.write_field_begin("total_byte_size", TType.i64, 2)
        oprot.write_i64(self.total_byte_size)
        oprot.write_field_end()

        oprot.write_field_begin("num_rows", TType.i64, 3)
        oprot.write_i64(self.num_rows)
        oprot.write_field_end()

        if self.sorting_columns:
            oprot.write_field_begin("sorting_columns", TType.list, 4)
            var size = len(self.sorting_columns.value())
            oprot.write_list_begin(TType.struct_, size)
            for iter59 in range(size):
                self.sorting_columns.value()[iter59].write(oprot)
            oprot.write_list_end()
            oprot.write_field_end()

        if self.file_offset:
            oprot.write_field_begin("file_offset", TType.i64, 5)
            oprot.write_i64(self.file_offset.value())
            oprot.write_field_end()

        if self.total_compressed_size:
            oprot.write_field_begin("total_compressed_size", TType.i64, 6)
            oprot.write_i64(self.total_compressed_size.value())
            oprot.write_field_end()

        if self.ordinal:
            oprot.write_field_begin("ordinal", TType.i16, 7)
            oprot.write_i16(self.ordinal.value())
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        columns = String("<>")

        total_byte_size = repr(self.total_byte_size)

        num_rows = repr(self.num_rows)

        if self.sorting_columns:
            sorting_columns = String("<>")
        else:
            sorting_columns = String("None")

        if self.file_offset:
            file_offset = repr(self.file_offset.value())
        else:
            file_offset = String("None")

        if self.total_compressed_size:
            total_compressed_size = repr(self.total_compressed_size.value())
        else:
            total_compressed_size = String("None")

        if self.ordinal:
            ordinal = repr(self.ordinal.value())
        else:
            ordinal = String("None")

        return String(
            "RowGroup(",
            columns, ", ",
            total_byte_size, ", ",
            num_rows, ", ",
            "Optional(", sorting_columns, "), ",
            "Optional(", file_offset, "), ",
            "Optional(", total_compressed_size, "), ",
            "Optional(", ordinal, ")",
            ")",
        )



@value 
struct TypeDefinedOrder(Representable):
    """
    Empty struct to signal the order defined by the physical or logical type

    """

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, _fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        return String(
            "TypeDefinedOrder(",
            ")",
        )



@value 
struct ColumnOrder(Representable):
    """
    Union to specify the order used for the min_value and max_value fields for a
    column. This union takes the role of an enhanced enum that allows rich
    elements (which will be needed for a collation-based ordering in the future).

    Possible values are:
    * TypeDefinedOrder - the column uses the order defined by its logical or
                         physical type (if there is no logical type).

    If the reader does not support the value of this union, min and max stats
    for this column should be ignored.

    Attributes:
     - TYPE_ORDER: The sort orders for logical types are:
      UTF8 - unsigned byte-wise comparison
      INT8 - signed comparison
      INT16 - signed comparison
      INT32 - signed comparison
      INT64 - signed comparison
      UINT8 - unsigned comparison
      UINT16 - unsigned comparison
      UINT32 - unsigned comparison
      UINT64 - unsigned comparison
      DECIMAL - signed comparison of the represented value
      DATE - signed comparison
      FLOAT16 - signed comparison of the represented value (*)
      TIME_MILLIS - signed comparison
      TIME_MICROS - signed comparison
      TIMESTAMP_MILLIS - signed comparison
      TIMESTAMP_MICROS - signed comparison
      INTERVAL - undefined
      JSON - unsigned byte-wise comparison
      BSON - unsigned byte-wise comparison
      ENUM - unsigned byte-wise comparison
      LIST - undefined
      MAP - undefined
      VARIANT - undefined
      GEOMETRY - undefined
      GEOGRAPHY - undefined

    In the absence of logical types, the sort order is determined by the physical type:
      BOOLEAN - false, true
      INT32 - signed comparison
      INT64 - signed comparison
      INT96 (only used for legacy timestamps) - undefined
      FLOAT - signed comparison of the represented value (*)
      DOUBLE - signed comparison of the represented value (*)
      BYTE_ARRAY - unsigned byte-wise comparison
      FIXED_LEN_BYTE_ARRAY - unsigned byte-wise comparison

    (*) Because the sorting order is not specified properly for floating
        point values (relations vs. total ordering) the following
        compatibility rules should be applied when reading statistics:
        - If the min is a NaN, it should be ignored.
        - If the max is a NaN, it should be ignored.
        - If the min is +0, the row group may contain -0 values as well.
        - If the max is -0, the row group may contain +0 values as well.
        - When looking for NaN values, min and max should be ignored.

        When writing statistics the following rules should be followed:
        - NaNs should not be written to min or max statistics fields.
        - If the computed max value is zero (whether negative or positive),
          `+0.0` should be written into the max statistics field.
        - If the computed min value is zero (whether negative or positive),
          `-0.0` should be written into the min statistics field.

    """
    var TYPE_ORDER: Optional[TypeDefinedOrder]

    fn __init__(out self, TYPE_ORDER: Optional[TypeDefinedOrder] = None,):
        self.TYPE_ORDER = TYPE_ORDER

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var TYPE_ORDER: Optional[TypeDefinedOrder] = None

        var received_field_count = 0

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.struct_:
                    TYPE_ORDER = TypeDefinedOrder.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        if received_field_count != 1:
            raise Error("Expected exactly one field to be set, but got", received_field_count)

        iprot.read_struct_end()

        return Self(
            TYPE_ORDER,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.TYPE_ORDER:
            oprot.write_field_begin("TYPE_ORDER", TType.struct_, 1)
            self.TYPE_ORDER.value().write(oprot)
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        var inner = String("None")
        if self.TYPE_ORDER:
            inner = repr(self.TYPE_ORDER.value())

        return String(
            "ColumnOrder(",
            inner,
            ")",
        )



@value 
struct PageLocation(Representable):
    """
    Attributes:
     - offset: Offset of the page in the file *
     - compressed_page_size: Size of the page, including header. Sum of compressed_page_size and header
    length
     - first_row_index: Index within the RowGroup of the first row of the page. When an
    OffsetIndex is present, pages must begin on row boundaries
    (repetition_level = 0).

    """
    var offset: Int64
    var compressed_page_size: Int32
    var first_row_index: Int64

    fn __init__(out self, offset: Int64, compressed_page_size: Int32, first_row_index: Int64,):
        self.offset = offset
        self.compressed_page_size = compressed_page_size
        self.first_row_index = first_row_index

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var offset: Optional[Int64] = None
        var compressed_page_size: Optional[Int32] = None
        var first_row_index: Optional[Int64] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.i64:
                    offset = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.i32:
                    compressed_page_size = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.i64:
                    first_row_index = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            offset.value(),
            compressed_page_size.value(),
            first_row_index.value(),
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("offset", TType.i64, 1)
        oprot.write_i64(self.offset)
        oprot.write_field_end()

        oprot.write_field_begin("compressed_page_size", TType.i32, 2)
        oprot.write_i32(self.compressed_page_size)
        oprot.write_field_end()

        oprot.write_field_begin("first_row_index", TType.i64, 3)
        oprot.write_i64(self.first_row_index)
        oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        offset = repr(self.offset)

        compressed_page_size = repr(self.compressed_page_size)

        first_row_index = repr(self.first_row_index)

        return String(
            "PageLocation(",
            offset, ", ",
            compressed_page_size, ", ",
            first_row_index,
            ")",
        )



@value 
struct OffsetIndex(Representable):
    """
    Optional offsets for each data page in a ColumnChunk.

    Forms part of the page index, along with ColumnIndex.

    OffsetIndex may be present even if ColumnIndex is not.

    Attributes:
     - page_locations: PageLocations, ordered by increasing PageLocation.offset. It is required
    that page_locations[i].first_row_index < page_locations[i+1].first_row_index.
     - unencoded_byte_array_data_bytes: Unencoded/uncompressed size for BYTE_ARRAY types.

    See documention for unencoded_byte_array_data_bytes in SizeStatistics for
    more details on this field.

    """
    var page_locations: List[PageLocation]
    var unencoded_byte_array_data_bytes: Optional[List[Int64]]

    fn __init__(out self, page_locations: List[PageLocation], unencoded_byte_array_data_bytes: Optional[List[Int64]],):
        self.page_locations = page_locations
        self.unencoded_byte_array_data_bytes = unencoded_byte_array_data_bytes

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var page_locations: Optional[List[PageLocation]] = None
        var unencoded_byte_array_data_bytes: Optional[List[Int64]] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.struct_)
                    page_locations = List[PageLocation](capacity=size)
                    for _ in range(size):
                        elem_64 = PageLocation.read(iprot)
                        page_locations.value().append(elem_64)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.i64)
                    unencoded_byte_array_data_bytes = List[Int64](capacity=size)
                    for _ in range(size):
                        elem_69 = iprot.read_i64()
                        unencoded_byte_array_data_bytes.value().append(elem_69)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            page_locations.value(),
            unencoded_byte_array_data_bytes,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("page_locations", TType.list, 1)
        var size = len(self.page_locations)
        oprot.write_list_begin(TType.struct_, size)
        for iter70 in range(size):
            self.page_locations[iter70].write(oprot)
        oprot.write_list_end()
        oprot.write_field_end()

        if self.unencoded_byte_array_data_bytes:
            oprot.write_field_begin("unencoded_byte_array_data_bytes", TType.list, 2)
            var size = len(self.unencoded_byte_array_data_bytes.value())
            oprot.write_list_begin(TType.i64, size)
            for iter71 in range(size):
                oprot.write_i64(self.unencoded_byte_array_data_bytes.value()[iter71])
            oprot.write_list_end()
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        page_locations = String("<>")

        if self.unencoded_byte_array_data_bytes:
            unencoded_byte_array_data_bytes = String("<>")
        else:
            unencoded_byte_array_data_bytes = String("None")

        return String(
            "OffsetIndex(",
            page_locations, ", ",
            "Optional(", unencoded_byte_array_data_bytes, ")",
            ")",
        )



@value 
struct ColumnIndex(Representable):
    """
    Optional statistics for each data page in a ColumnChunk.

    Forms part the page index, along with OffsetIndex.

    If this structure is present, OffsetIndex must also be present.

    For each field in this structure, <field>[i] refers to the page at
    OffsetIndex.page_locations[i]

    Attributes:
     - null_pages: A list of Boolean values to determine the validity of the corresponding
    min and max values. If true, a page contains only null values, and writers
    have to set the corresponding entries in min_values and max_values to
    byte[0], so that all lists have the same length. If false, the
    corresponding entries in min_values and max_values must be valid.
     - min_values: Two lists containing lower and upper bounds for the values of each page
    determined by the ColumnOrder of the column. These may be the actual
    minimum and maximum values found on a page, but can also be (more compact)
    values that do not exist on a page. For example, instead of storing ""Blart
    Versenwald III", a writer may set min_values[i]="B", max_values[i]="C".
    Such more compact values must still be valid values within the column's
    logical type. Readers must make sure that list entries are populated before
    using them by inspecting null_pages.
     - max_values
     - boundary_order: Stores whether both min_values and max_values are ordered and if so, in
    which direction. This allows readers to perform binary searches in both
    lists. Readers cannot assume that max_values[i] <= min_values[i+1], even
    if the lists are ordered.
     - null_counts: A list containing the number of null values for each page

    Writers SHOULD always write this field even if no null values
    are present or the column is not nullable.
    Readers MUST distinguish between null_counts not being present
    and null_count being 0.
    If null_counts are not present, readers MUST NOT assume all
    null counts are 0.
     - repetition_level_histograms: Contains repetition level histograms for each page
    concatenated together.  The repetition_level_histogram field on
    SizeStatistics contains more details.

    When present the length should always be (number of pages *
    (max_repetition_level + 1)) elements.

    Element 0 is the first element of the histogram for the first page.
    Element (max_repetition_level + 1) is the first element of the histogram
    for the second page.

     - definition_level_histograms: Same as repetition_level_histograms except for definitions levels.


    """
    var null_pages: List[Bool]
    var min_values: List[List[UInt8]]
    var max_values: List[List[UInt8]]
    var boundary_order: BoundaryOrder
    var null_counts: Optional[List[Int64]]
    var repetition_level_histograms: Optional[List[Int64]]
    var definition_level_histograms: Optional[List[Int64]]

    fn __init__(out self, null_pages: List[Bool], min_values: List[List[UInt8]], max_values: List[List[UInt8]], boundary_order: BoundaryOrder, null_counts: Optional[List[Int64]], repetition_level_histograms: Optional[List[Int64]], definition_level_histograms: Optional[List[Int64]],):
        self.null_pages = null_pages
        self.min_values = min_values
        self.max_values = max_values
        self.boundary_order = boundary_order
        self.null_counts = null_counts
        self.repetition_level_histograms = repetition_level_histograms
        self.definition_level_histograms = definition_level_histograms

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var null_pages: Optional[List[Bool]] = None
        var min_values: Optional[List[List[UInt8]]] = None
        var max_values: Optional[List[List[UInt8]]] = None
        var boundary_order: Optional[BoundaryOrder] = None
        var null_counts: Optional[List[Int64]] = None
        var repetition_level_histograms: Optional[List[Int64]] = None
        var definition_level_histograms: Optional[List[Int64]] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.bool)
                    null_pages = List[Bool](capacity=size)
                    for _ in range(size):
                        elem_76 = iprot.read_bool()
                        null_pages.value().append(elem_76)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.binary)
                    min_values = List[List[UInt8]](capacity=size)
                    for _ in range(size):
                        elem_81 = iprot.read_binary()
                        min_values.value().append(elem_81)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.binary)
                    max_values = List[List[UInt8]](capacity=size)
                    for _ in range(size):
                        elem_86 = iprot.read_binary()
                        max_values.value().append(elem_86)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.i32:
                    boundary_order = BoundaryOrder(iprot.read_i32())
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.i64)
                    null_counts = List[Int64](capacity=size)
                    for _ in range(size):
                        elem_91 = iprot.read_i64()
                        null_counts.value().append(elem_91)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.i64)
                    repetition_level_histograms = List[Int64](capacity=size)
                    for _ in range(size):
                        elem_96 = iprot.read_i64()
                        repetition_level_histograms.value().append(elem_96)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.i64)
                    definition_level_histograms = List[Int64](capacity=size)
                    for _ in range(size):
                        elem_101 = iprot.read_i64()
                        definition_level_histograms.value().append(elem_101)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            null_pages.value(),
            min_values.value(),
            max_values.value(),
            boundary_order.value(),
            null_counts,
            repetition_level_histograms,
            definition_level_histograms,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("null_pages", TType.list, 1)
        var size = len(self.null_pages)
        oprot.write_list_begin(TType.bool, size)
        for iter102 in range(size):
            oprot.write_bool(self.null_pages[iter102])
        oprot.write_list_end()
        oprot.write_field_end()

        oprot.write_field_begin("min_values", TType.list, 2)
        var size = len(self.min_values)
        oprot.write_list_begin(TType.binary, size)
        for iter103 in range(size):
            oprot.write_binary(self.min_values[iter103])
        oprot.write_list_end()
        oprot.write_field_end()

        oprot.write_field_begin("max_values", TType.list, 3)
        var size = len(self.max_values)
        oprot.write_list_begin(TType.binary, size)
        for iter104 in range(size):
            oprot.write_binary(self.max_values[iter104])
        oprot.write_list_end()
        oprot.write_field_end()

        oprot.write_field_begin("boundary_order", TType.i32, 4)
        oprot.write_i32(self.boundary_order.to_i32())
        oprot.write_field_end()

        if self.null_counts:
            oprot.write_field_begin("null_counts", TType.list, 5)
            var size = len(self.null_counts.value())
            oprot.write_list_begin(TType.i64, size)
            for iter105 in range(size):
                oprot.write_i64(self.null_counts.value()[iter105])
            oprot.write_list_end()
            oprot.write_field_end()

        if self.repetition_level_histograms:
            oprot.write_field_begin("repetition_level_histograms", TType.list, 6)
            var size = len(self.repetition_level_histograms.value())
            oprot.write_list_begin(TType.i64, size)
            for iter106 in range(size):
                oprot.write_i64(self.repetition_level_histograms.value()[iter106])
            oprot.write_list_end()
            oprot.write_field_end()

        if self.definition_level_histograms:
            oprot.write_field_begin("definition_level_histograms", TType.list, 7)
            var size = len(self.definition_level_histograms.value())
            oprot.write_list_begin(TType.i64, size)
            for iter107 in range(size):
                oprot.write_i64(self.definition_level_histograms.value()[iter107])
            oprot.write_list_end()
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        null_pages = String("<>")

        min_values = String("<>")

        max_values = String("<>")

        boundary_order = repr(self.boundary_order)

        if self.null_counts:
            null_counts = String("<>")
        else:
            null_counts = String("None")

        if self.repetition_level_histograms:
            repetition_level_histograms = String("<>")
        else:
            repetition_level_histograms = String("None")

        if self.definition_level_histograms:
            definition_level_histograms = String("<>")
        else:
            definition_level_histograms = String("None")

        return String(
            "ColumnIndex(",
            null_pages, ", ",
            min_values, ", ",
            max_values, ", ",
            boundary_order, ", ",
            "Optional(", null_counts, "), ",
            "Optional(", repetition_level_histograms, "), ",
            "Optional(", definition_level_histograms, ")",
            ")",
        )



@value 
struct AesGcmV1(Representable):
    """
    Attributes:
     - aad_prefix: AAD prefix *
     - aad_file_unique: Unique file identifier part of AAD suffix *
     - supply_aad_prefix: In files encrypted with AAD prefix without storing it,
    readers must supply the prefix *

    """
    var aad_prefix: Optional[List[UInt8]]
    var aad_file_unique: Optional[List[UInt8]]
    var supply_aad_prefix: Optional[Bool]

    fn __init__(out self, aad_prefix: Optional[List[UInt8]], aad_file_unique: Optional[List[UInt8]], supply_aad_prefix: Optional[Bool],):
        self.aad_prefix = aad_prefix
        self.aad_file_unique = aad_file_unique
        self.supply_aad_prefix = supply_aad_prefix

    @staticmethod
    fn repr_bytes(bytes: List[UInt8]) -> String:
        var s = String("[")
        for i in range(len(bytes)):
            s += repr(bytes[i])
            if i < len(bytes) - 1:
                s += ", "
        s += "]"
        return s

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var aad_prefix: Optional[List[UInt8]] = None
        var aad_file_unique: Optional[List[UInt8]] = None
        var supply_aad_prefix: Optional[Bool] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.binary:
                    aad_prefix = iprot.read_binary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.binary:
                    aad_file_unique = iprot.read_binary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.bool:
                    supply_aad_prefix = iprot.read_bool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            aad_prefix,
            aad_file_unique,
            supply_aad_prefix,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.aad_prefix:
            oprot.write_field_begin("aad_prefix", TType.binary, 1)
            oprot.write_binary(self.aad_prefix.value())
            oprot.write_field_end()

        if self.aad_file_unique:
            oprot.write_field_begin("aad_file_unique", TType.binary, 2)
            oprot.write_binary(self.aad_file_unique.value())
            oprot.write_field_end()

        if self.supply_aad_prefix:
            oprot.write_field_begin("supply_aad_prefix", TType.bool, 3)
            oprot.write_bool(self.supply_aad_prefix.value())
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        if self.aad_prefix:
            aad_prefix = Self.repr_bytes(self.aad_prefix.value())
        else:
            aad_prefix = String("None")

        if self.aad_file_unique:
            aad_file_unique = Self.repr_bytes(self.aad_file_unique.value())
        else:
            aad_file_unique = String("None")

        if self.supply_aad_prefix:
            supply_aad_prefix = repr(self.supply_aad_prefix.value())
        else:
            supply_aad_prefix = String("None")

        return String(
            "AesGcmV1(",
            "Optional(", aad_prefix, "), ",
            "Optional(", aad_file_unique, "), ",
            "Optional(", supply_aad_prefix, ")",
            ")",
        )



@value 
struct AesGcmCtrV1(Representable):
    """
    Attributes:
     - aad_prefix: AAD prefix *
     - aad_file_unique: Unique file identifier part of AAD suffix *
     - supply_aad_prefix: In files encrypted with AAD prefix without storing it,
    readers must supply the prefix *

    """
    var aad_prefix: Optional[List[UInt8]]
    var aad_file_unique: Optional[List[UInt8]]
    var supply_aad_prefix: Optional[Bool]

    fn __init__(out self, aad_prefix: Optional[List[UInt8]], aad_file_unique: Optional[List[UInt8]], supply_aad_prefix: Optional[Bool],):
        self.aad_prefix = aad_prefix
        self.aad_file_unique = aad_file_unique
        self.supply_aad_prefix = supply_aad_prefix

    @staticmethod
    fn repr_bytes(bytes: List[UInt8]) -> String:
        var s = String("[")
        for i in range(len(bytes)):
            s += repr(bytes[i])
            if i < len(bytes) - 1:
                s += ", "
        s += "]"
        return s

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var aad_prefix: Optional[List[UInt8]] = None
        var aad_file_unique: Optional[List[UInt8]] = None
        var supply_aad_prefix: Optional[Bool] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.binary:
                    aad_prefix = iprot.read_binary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.binary:
                    aad_file_unique = iprot.read_binary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.bool:
                    supply_aad_prefix = iprot.read_bool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            aad_prefix,
            aad_file_unique,
            supply_aad_prefix,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.aad_prefix:
            oprot.write_field_begin("aad_prefix", TType.binary, 1)
            oprot.write_binary(self.aad_prefix.value())
            oprot.write_field_end()

        if self.aad_file_unique:
            oprot.write_field_begin("aad_file_unique", TType.binary, 2)
            oprot.write_binary(self.aad_file_unique.value())
            oprot.write_field_end()

        if self.supply_aad_prefix:
            oprot.write_field_begin("supply_aad_prefix", TType.bool, 3)
            oprot.write_bool(self.supply_aad_prefix.value())
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        if self.aad_prefix:
            aad_prefix = Self.repr_bytes(self.aad_prefix.value())
        else:
            aad_prefix = String("None")

        if self.aad_file_unique:
            aad_file_unique = Self.repr_bytes(self.aad_file_unique.value())
        else:
            aad_file_unique = String("None")

        if self.supply_aad_prefix:
            supply_aad_prefix = repr(self.supply_aad_prefix.value())
        else:
            supply_aad_prefix = String("None")

        return String(
            "AesGcmCtrV1(",
            "Optional(", aad_prefix, "), ",
            "Optional(", aad_file_unique, "), ",
            "Optional(", supply_aad_prefix, ")",
            ")",
        )



@value 
struct EncryptionAlgorithm(Representable):
    """
    Attributes:
     - AES_GCM_V1
     - AES_GCM_CTR_V1

    """
    var AES_GCM_V1: Optional[AesGcmV1]
    var AES_GCM_CTR_V1: Optional[AesGcmCtrV1]

    fn __init__(out self, AES_GCM_V1: Optional[AesGcmV1] = None, AES_GCM_CTR_V1: Optional[AesGcmCtrV1] = None,):
        self.AES_GCM_V1 = AES_GCM_V1
        self.AES_GCM_CTR_V1 = AES_GCM_CTR_V1

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var AES_GCM_V1: Optional[AesGcmV1] = None
        var AES_GCM_CTR_V1: Optional[AesGcmCtrV1] = None

        var received_field_count = 0

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.struct_:
                    AES_GCM_V1 = AesGcmV1.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            elif fid == 2:
                if ftype == TType.struct_:
                    AES_GCM_CTR_V1 = AesGcmCtrV1.read(iprot)
                else:
                    iprot.skip(ftype)
                received_field_count += 1
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        if received_field_count != 1:
            raise Error("Expected exactly one field to be set, but got", received_field_count)

        iprot.read_struct_end()

        return Self(
            AES_GCM_V1,
            AES_GCM_CTR_V1,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        if self.AES_GCM_V1:
            oprot.write_field_begin("AES_GCM_V1", TType.struct_, 1)
            self.AES_GCM_V1.value().write(oprot)
            oprot.write_field_end()

        if self.AES_GCM_CTR_V1:
            oprot.write_field_begin("AES_GCM_CTR_V1", TType.struct_, 2)
            self.AES_GCM_CTR_V1.value().write(oprot)
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        var inner = String("None")
        if self.AES_GCM_V1:
            inner = repr(self.AES_GCM_V1.value())

        if self.AES_GCM_CTR_V1:
            inner = repr(self.AES_GCM_CTR_V1.value())

        return String(
            "EncryptionAlgorithm(",
            inner,
            ")",
        )



@value 
struct FileMetaData(Representable):
    """
    Description for file metadata

    Attributes:
     - version: Version of this file *
     - schema: Parquet schema for this file.  This schema contains metadata for all the columns.
    The schema is represented as a tree with a single root.  The nodes of the tree
    are flattened to a list by doing a depth-first traversal.
    The column metadata contains the path in the schema for that column which can be
    used to map columns to nodes in the schema.
    The first element is the root *
     - num_rows: Number of rows in this file *
     - row_groups: Row groups in this file *
     - key_value_metadata: Optional key/value metadata *
     - created_by: String for application that wrote this file.  This should be in the format
    <Application> version <App Version> (build <App Build Hash>).
    e.g. impala version 1.0 (build 6cf94d29b2b7115df4de2c06e2ab4326d721eb55)

     - column_orders: Sort order used for the min_value and max_value fields in the Statistics
    objects and the min_values and max_values fields in the ColumnIndex
    objects of each column in this file. Sort orders are listed in the order
    matching the columns in the schema. The indexes are not necessary the same
    though, because only leaf nodes of the schema are represented in the list
    of sort orders.

    Without column_orders, the meaning of the min_value and max_value fields
    in the Statistics object and the ColumnIndex object is undefined. To ensure
    well-defined behaviour, if these fields are written to a Parquet file,
    column_orders must be written as well.

    The obsolete min and max fields in the Statistics object are always sorted
    by signed comparison regardless of column_orders.
     - encryption_algorithm: Encryption algorithm. This field is set only in encrypted files
    with plaintext footer. Files with encrypted footer store algorithm id
    in FileCryptoMetaData structure.
     - footer_signing_key_metadata: Retrieval metadata of key used for signing the footer.
    Used only in encrypted files with plaintext footer.

    """
    var version: Int32
    var schema: List[SchemaElement]
    var num_rows: Int64
    var row_groups: List[RowGroup]
    var key_value_metadata: Optional[List[KeyValue]]
    var created_by: Optional[String]
    var column_orders: Optional[List[ColumnOrder]]
    var encryption_algorithm: Optional[EncryptionAlgorithm]
    var footer_signing_key_metadata: Optional[List[UInt8]]

    fn __init__(out self, version: Int32, schema: List[SchemaElement], num_rows: Int64, row_groups: List[RowGroup], key_value_metadata: Optional[List[KeyValue]], created_by: Optional[String], column_orders: Optional[List[ColumnOrder]], encryption_algorithm: Optional[EncryptionAlgorithm], footer_signing_key_metadata: Optional[List[UInt8]],):
        self.version = version
        self.schema = schema
        self.num_rows = num_rows
        self.row_groups = row_groups
        self.key_value_metadata = key_value_metadata
        self.created_by = created_by
        self.column_orders = column_orders
        self.encryption_algorithm = encryption_algorithm
        self.footer_signing_key_metadata = footer_signing_key_metadata

    @staticmethod
    fn repr_bytes(bytes: List[UInt8]) -> String:
        var s = String("[")
        for i in range(len(bytes)):
            s += repr(bytes[i])
            if i < len(bytes) - 1:
                s += ", "
        s += "]"
        return s

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var version: Optional[Int32] = None
        var schema: Optional[List[SchemaElement]] = None
        var num_rows: Optional[Int64] = None
        var row_groups: Optional[List[RowGroup]] = None
        var key_value_metadata: Optional[List[KeyValue]] = None
        var created_by: Optional[String] = None
        var column_orders: Optional[List[ColumnOrder]] = None
        var encryption_algorithm: Optional[EncryptionAlgorithm] = None
        var footer_signing_key_metadata: Optional[List[UInt8]] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.i32:
                    version = iprot.read_i32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.struct_)
                    schema = List[SchemaElement](capacity=size)
                    for _ in range(size):
                        elem_112 = SchemaElement.read(iprot)
                        schema.value().append(elem_112)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.i64:
                    num_rows = iprot.read_i64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.struct_)
                    row_groups = List[RowGroup](capacity=size)
                    for _ in range(size):
                        elem_117 = RowGroup.read(iprot)
                        row_groups.value().append(elem_117)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.struct_)
                    key_value_metadata = List[KeyValue](capacity=size)
                    for _ in range(size):
                        elem_122 = KeyValue.read(iprot)
                        key_value_metadata.value().append(elem_122)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.string:
                    created_by = iprot.read_string()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.list:
                    var size = iprot.read_list_begin(TType.struct_)
                    column_orders = List[ColumnOrder](capacity=size)
                    for _ in range(size):
                        elem_127 = ColumnOrder.read(iprot)
                        column_orders.value().append(elem_127)
                    iprot.read_list_end()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.struct_:
                    encryption_algorithm = EncryptionAlgorithm.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.binary:
                    footer_signing_key_metadata = iprot.read_binary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            version.value(),
            schema.value(),
            num_rows.value(),
            row_groups.value(),
            key_value_metadata,
            created_by,
            column_orders,
            encryption_algorithm,
            footer_signing_key_metadata,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("version", TType.i32, 1)
        oprot.write_i32(self.version)
        oprot.write_field_end()

        oprot.write_field_begin("schema", TType.list, 2)
        var size = len(self.schema)
        oprot.write_list_begin(TType.struct_, size)
        for iter128 in range(size):
            self.schema[iter128].write(oprot)
        oprot.write_list_end()
        oprot.write_field_end()

        oprot.write_field_begin("num_rows", TType.i64, 3)
        oprot.write_i64(self.num_rows)
        oprot.write_field_end()

        oprot.write_field_begin("row_groups", TType.list, 4)
        var size = len(self.row_groups)
        oprot.write_list_begin(TType.struct_, size)
        for iter129 in range(size):
            self.row_groups[iter129].write(oprot)
        oprot.write_list_end()
        oprot.write_field_end()

        if self.key_value_metadata:
            oprot.write_field_begin("key_value_metadata", TType.list, 5)
            var size = len(self.key_value_metadata.value())
            oprot.write_list_begin(TType.struct_, size)
            for iter130 in range(size):
                self.key_value_metadata.value()[iter130].write(oprot)
            oprot.write_list_end()
            oprot.write_field_end()

        if self.created_by:
            oprot.write_field_begin("created_by", TType.string, 6)
            oprot.write_string(self.created_by.value())
            oprot.write_field_end()

        if self.column_orders:
            oprot.write_field_begin("column_orders", TType.list, 7)
            var size = len(self.column_orders.value())
            oprot.write_list_begin(TType.struct_, size)
            for iter131 in range(size):
                self.column_orders.value()[iter131].write(oprot)
            oprot.write_list_end()
            oprot.write_field_end()

        if self.encryption_algorithm:
            oprot.write_field_begin("encryption_algorithm", TType.struct_, 8)
            self.encryption_algorithm.value().write(oprot)
            oprot.write_field_end()

        if self.footer_signing_key_metadata:
            oprot.write_field_begin("footer_signing_key_metadata", TType.binary, 9)
            oprot.write_binary(self.footer_signing_key_metadata.value())
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        version = repr(self.version)

        schema = String("<>")

        num_rows = repr(self.num_rows)

        row_groups = String("<>")

        if self.key_value_metadata:
            key_value_metadata = String("<>")
        else:
            key_value_metadata = String("None")

        if self.created_by:
            created_by = repr(self.created_by.value())
        else:
            created_by = String("None")

        if self.column_orders:
            column_orders = String("<>")
        else:
            column_orders = String("None")

        if self.encryption_algorithm:
            encryption_algorithm = repr(self.encryption_algorithm.value())
        else:
            encryption_algorithm = String("None")

        if self.footer_signing_key_metadata:
            footer_signing_key_metadata = Self.repr_bytes(self.footer_signing_key_metadata.value())
        else:
            footer_signing_key_metadata = String("None")

        return String(
            "FileMetaData(",
            version, ", ",
            schema, ", ",
            num_rows, ", ",
            row_groups, ", ",
            "Optional(", key_value_metadata, "), ",
            "Optional(", created_by, "), ",
            "Optional(", column_orders, "), ",
            "Optional(", encryption_algorithm, "), ",
            "Optional(", footer_signing_key_metadata, ")",
            ")",
        )



@value 
struct FileCryptoMetaData(Representable):
    """
    Crypto metadata for files with encrypted footer *

    Attributes:
     - encryption_algorithm: Encryption algorithm. This field is only used for files
    with encrypted footer. Files with plaintext footer store algorithm id
    inside footer (FileMetaData structure).
     - key_metadata: Retrieval metadata of key used for encryption of footer,
    and (possibly) columns *

    """
    var encryption_algorithm: EncryptionAlgorithm
    var key_metadata: Optional[List[UInt8]]

    fn __init__(out self, encryption_algorithm: EncryptionAlgorithm, key_metadata: Optional[List[UInt8]],):
        self.encryption_algorithm = encryption_algorithm
        self.key_metadata = key_metadata

    @staticmethod
    fn repr_bytes(bytes: List[UInt8]) -> String:
        var s = String("[")
        for i in range(len(bytes)):
            s += repr(bytes[i])
            if i < len(bytes) - 1:
                s += ", "
        s += "]"
        return s

    @staticmethod
    fn read[T: TProtocol](mut iprot: T) raises -> Self:
        var encryption_algorithm: Optional[EncryptionAlgorithm] = None
        var key_metadata: Optional[List[UInt8]] = None

        iprot.read_struct_begin()
        while True:
            (_fname, ftype, fid) = iprot.read_field_begin()
            if ftype == TType.stop:
                break
            if fid == 1:
                if ftype == TType.struct_:
                    encryption_algorithm = EncryptionAlgorithm.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.binary:
                    key_metadata = iprot.read_binary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.read_field_end()
        iprot.read_struct_end()

        return Self(
            encryption_algorithm.value(),
            key_metadata,
        )

    fn write[T: TProtocol](self, mut oprot: T) raises -> None:
        oprot.write_struct_begin()

        oprot.write_field_begin("encryption_algorithm", TType.struct_, 1)
        self.encryption_algorithm.write(oprot)
        oprot.write_field_end()

        if self.key_metadata:
            oprot.write_field_begin("key_metadata", TType.binary, 2)
            oprot.write_binary(self.key_metadata.value())
            oprot.write_field_end()


        oprot.write_field_stop()
        oprot.write_struct_end()

    fn __repr__(self) -> String:
        encryption_algorithm = repr(self.encryption_algorithm)

        if self.key_metadata:
            key_metadata = Self.repr_bytes(self.key_metadata.value())
        else:
            key_metadata = String("None")

        return String(
            "FileCryptoMetaData(",
            encryption_algorithm, ", ",
            "Optional(", key_metadata, ")",
            ")",
        )

